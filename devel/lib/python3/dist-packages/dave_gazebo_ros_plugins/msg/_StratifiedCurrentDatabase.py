# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from dave_gazebo_ros_plugins/StratifiedCurrentDatabase.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import geometry_msgs.msg

class StratifiedCurrentDatabase(genpy.Message):
  _md5sum = "cae79f9939f13721eab1911acfc60050"
  _type = "dave_gazebo_ros_plugins/StratifiedCurrentDatabase"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """# Publishes depths and velocities read from the csv database

# Depths
float32[] depths

# Velocities
geometry_msgs/Vector3[] velocities

# Tide time (GMT)
int16[] timeGMTYear
int16[] timeGMTMonth
int16[] timeGMTDay
int16[] timeGMTHour
int16[] timeGMTMinute

# Tide velocities
float32[] tideVelocities

# Tide constituents
bool tideConstituents
float32 M2amp
float32 M2phase
float32 M2speed
float32 S2amp
float32 S2phase
float32 S2speed
float32 N2amp
float32 N2phase
float32 N2speed

# Tide direction
float32 ebbDirection
float32 floodDirection

# World start time (GMT)
int16 worldStartTimeYear
int16 worldStartTimeMonth
int16 worldStartTimeDay
int16 worldStartTimeHour
int16 worldStartTimeMinute
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space. 
# It is only meant to represent a direction. Therefore, it does not
# make sense to apply a translation to it (e.g., when applying a 
# generic rigid transformation to a Vector3, tf2 will only apply the
# rotation). If you want your data to be translatable too, use the
# geometry_msgs/Point message instead.

float64 x
float64 y
float64 z"""
  __slots__ = ['depths','velocities','timeGMTYear','timeGMTMonth','timeGMTDay','timeGMTHour','timeGMTMinute','tideVelocities','tideConstituents','M2amp','M2phase','M2speed','S2amp','S2phase','S2speed','N2amp','N2phase','N2speed','ebbDirection','floodDirection','worldStartTimeYear','worldStartTimeMonth','worldStartTimeDay','worldStartTimeHour','worldStartTimeMinute']
  _slot_types = ['float32[]','geometry_msgs/Vector3[]','int16[]','int16[]','int16[]','int16[]','int16[]','float32[]','bool','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32','int16','int16','int16','int16','int16']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       depths,velocities,timeGMTYear,timeGMTMonth,timeGMTDay,timeGMTHour,timeGMTMinute,tideVelocities,tideConstituents,M2amp,M2phase,M2speed,S2amp,S2phase,S2speed,N2amp,N2phase,N2speed,ebbDirection,floodDirection,worldStartTimeYear,worldStartTimeMonth,worldStartTimeDay,worldStartTimeHour,worldStartTimeMinute

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(StratifiedCurrentDatabase, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.depths is None:
        self.depths = []
      if self.velocities is None:
        self.velocities = []
      if self.timeGMTYear is None:
        self.timeGMTYear = []
      if self.timeGMTMonth is None:
        self.timeGMTMonth = []
      if self.timeGMTDay is None:
        self.timeGMTDay = []
      if self.timeGMTHour is None:
        self.timeGMTHour = []
      if self.timeGMTMinute is None:
        self.timeGMTMinute = []
      if self.tideVelocities is None:
        self.tideVelocities = []
      if self.tideConstituents is None:
        self.tideConstituents = False
      if self.M2amp is None:
        self.M2amp = 0.
      if self.M2phase is None:
        self.M2phase = 0.
      if self.M2speed is None:
        self.M2speed = 0.
      if self.S2amp is None:
        self.S2amp = 0.
      if self.S2phase is None:
        self.S2phase = 0.
      if self.S2speed is None:
        self.S2speed = 0.
      if self.N2amp is None:
        self.N2amp = 0.
      if self.N2phase is None:
        self.N2phase = 0.
      if self.N2speed is None:
        self.N2speed = 0.
      if self.ebbDirection is None:
        self.ebbDirection = 0.
      if self.floodDirection is None:
        self.floodDirection = 0.
      if self.worldStartTimeYear is None:
        self.worldStartTimeYear = 0
      if self.worldStartTimeMonth is None:
        self.worldStartTimeMonth = 0
      if self.worldStartTimeDay is None:
        self.worldStartTimeDay = 0
      if self.worldStartTimeHour is None:
        self.worldStartTimeHour = 0
      if self.worldStartTimeMinute is None:
        self.worldStartTimeMinute = 0
    else:
      self.depths = []
      self.velocities = []
      self.timeGMTYear = []
      self.timeGMTMonth = []
      self.timeGMTDay = []
      self.timeGMTHour = []
      self.timeGMTMinute = []
      self.tideVelocities = []
      self.tideConstituents = False
      self.M2amp = 0.
      self.M2phase = 0.
      self.M2speed = 0.
      self.S2amp = 0.
      self.S2phase = 0.
      self.S2speed = 0.
      self.N2amp = 0.
      self.N2phase = 0.
      self.N2speed = 0.
      self.ebbDirection = 0.
      self.floodDirection = 0.
      self.worldStartTimeYear = 0
      self.worldStartTimeMonth = 0
      self.worldStartTimeDay = 0
      self.worldStartTimeHour = 0
      self.worldStartTimeMinute = 0

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      length = len(self.depths)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(struct.Struct(pattern).pack(*self.depths))
      length = len(self.velocities)
      buff.write(_struct_I.pack(length))
      for val1 in self.velocities:
        _x = val1
        buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
      length = len(self.timeGMTYear)
      buff.write(_struct_I.pack(length))
      pattern = '<%sh'%length
      buff.write(struct.Struct(pattern).pack(*self.timeGMTYear))
      length = len(self.timeGMTMonth)
      buff.write(_struct_I.pack(length))
      pattern = '<%sh'%length
      buff.write(struct.Struct(pattern).pack(*self.timeGMTMonth))
      length = len(self.timeGMTDay)
      buff.write(_struct_I.pack(length))
      pattern = '<%sh'%length
      buff.write(struct.Struct(pattern).pack(*self.timeGMTDay))
      length = len(self.timeGMTHour)
      buff.write(_struct_I.pack(length))
      pattern = '<%sh'%length
      buff.write(struct.Struct(pattern).pack(*self.timeGMTHour))
      length = len(self.timeGMTMinute)
      buff.write(_struct_I.pack(length))
      pattern = '<%sh'%length
      buff.write(struct.Struct(pattern).pack(*self.timeGMTMinute))
      length = len(self.tideVelocities)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(struct.Struct(pattern).pack(*self.tideVelocities))
      _x = self
      buff.write(_get_struct_B11f5h().pack(_x.tideConstituents, _x.M2amp, _x.M2phase, _x.M2speed, _x.S2amp, _x.S2phase, _x.S2speed, _x.N2amp, _x.N2phase, _x.N2speed, _x.ebbDirection, _x.floodDirection, _x.worldStartTimeYear, _x.worldStartTimeMonth, _x.worldStartTimeDay, _x.worldStartTimeHour, _x.worldStartTimeMinute))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.velocities is None:
        self.velocities = None
      end = 0
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.depths = s.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.velocities = []
      for i in range(0, length):
        val1 = geometry_msgs.msg.Vector3()
        _x = val1
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
        self.velocities.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sh'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.timeGMTYear = s.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sh'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.timeGMTMonth = s.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sh'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.timeGMTDay = s.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sh'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.timeGMTHour = s.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sh'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.timeGMTMinute = s.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.tideVelocities = s.unpack(str[start:end])
      _x = self
      start = end
      end += 55
      (_x.tideConstituents, _x.M2amp, _x.M2phase, _x.M2speed, _x.S2amp, _x.S2phase, _x.S2speed, _x.N2amp, _x.N2phase, _x.N2speed, _x.ebbDirection, _x.floodDirection, _x.worldStartTimeYear, _x.worldStartTimeMonth, _x.worldStartTimeDay, _x.worldStartTimeHour, _x.worldStartTimeMinute,) = _get_struct_B11f5h().unpack(str[start:end])
      self.tideConstituents = bool(self.tideConstituents)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      length = len(self.depths)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(self.depths.tostring())
      length = len(self.velocities)
      buff.write(_struct_I.pack(length))
      for val1 in self.velocities:
        _x = val1
        buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
      length = len(self.timeGMTYear)
      buff.write(_struct_I.pack(length))
      pattern = '<%sh'%length
      buff.write(self.timeGMTYear.tostring())
      length = len(self.timeGMTMonth)
      buff.write(_struct_I.pack(length))
      pattern = '<%sh'%length
      buff.write(self.timeGMTMonth.tostring())
      length = len(self.timeGMTDay)
      buff.write(_struct_I.pack(length))
      pattern = '<%sh'%length
      buff.write(self.timeGMTDay.tostring())
      length = len(self.timeGMTHour)
      buff.write(_struct_I.pack(length))
      pattern = '<%sh'%length
      buff.write(self.timeGMTHour.tostring())
      length = len(self.timeGMTMinute)
      buff.write(_struct_I.pack(length))
      pattern = '<%sh'%length
      buff.write(self.timeGMTMinute.tostring())
      length = len(self.tideVelocities)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(self.tideVelocities.tostring())
      _x = self
      buff.write(_get_struct_B11f5h().pack(_x.tideConstituents, _x.M2amp, _x.M2phase, _x.M2speed, _x.S2amp, _x.S2phase, _x.S2speed, _x.N2amp, _x.N2phase, _x.N2speed, _x.ebbDirection, _x.floodDirection, _x.worldStartTimeYear, _x.worldStartTimeMonth, _x.worldStartTimeDay, _x.worldStartTimeHour, _x.worldStartTimeMinute))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.velocities is None:
        self.velocities = None
      end = 0
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.depths = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.velocities = []
      for i in range(0, length):
        val1 = geometry_msgs.msg.Vector3()
        _x = val1
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
        self.velocities.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sh'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.timeGMTYear = numpy.frombuffer(str[start:end], dtype=numpy.int16, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sh'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.timeGMTMonth = numpy.frombuffer(str[start:end], dtype=numpy.int16, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sh'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.timeGMTDay = numpy.frombuffer(str[start:end], dtype=numpy.int16, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sh'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.timeGMTHour = numpy.frombuffer(str[start:end], dtype=numpy.int16, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sh'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.timeGMTMinute = numpy.frombuffer(str[start:end], dtype=numpy.int16, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.tideVelocities = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
      _x = self
      start = end
      end += 55
      (_x.tideConstituents, _x.M2amp, _x.M2phase, _x.M2speed, _x.S2amp, _x.S2phase, _x.S2speed, _x.N2amp, _x.N2phase, _x.N2speed, _x.ebbDirection, _x.floodDirection, _x.worldStartTimeYear, _x.worldStartTimeMonth, _x.worldStartTimeDay, _x.worldStartTimeHour, _x.worldStartTimeMinute,) = _get_struct_B11f5h().unpack(str[start:end])
      self.tideConstituents = bool(self.tideConstituents)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_3d = None
def _get_struct_3d():
    global _struct_3d
    if _struct_3d is None:
        _struct_3d = struct.Struct("<3d")
    return _struct_3d
_struct_B11f5h = None
def _get_struct_B11f5h():
    global _struct_B11f5h
    if _struct_B11f5h is None:
        _struct_B11f5h = struct.Struct("<B11f5h")
    return _struct_B11f5h
