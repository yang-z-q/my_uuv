# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from ds_sensor_msgs/RdiPD0.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import ds_core_msgs.msg
import genpy
import std_msgs.msg

class RdiPD0(genpy.Message):
  _md5sum = "f798d30dd811f4b9295fc2ce59ff6c2d"
  _type = "ds_sensor_msgs/RdiPD0"
  _has_header = True  # flag to mark the presence of a Header object
  _full_text = """# The standard 2-part DsHeader block
# This allows both a standard ROS header and DS-specific header blocks
# See HEADERS.md in ds_core_msgs for details
std_msgs/Header header
ds_core_msgs/DsHeader ds_header

################################
# Standard DVL type disclaimer #
################################

# Standard array with one piston transducer for each beam
# If you have 4-5 individual disks on your DVL, use this one.
# Examples include Sonardyne Syrinx, Nortek DVLs, and RDI Workhorse
uint8 DVL_TYPE_PISTON=0

# Newfangled phased-array DVL.  If you have one giant disk with complicated stuff on it,
# probably this one.
# Examples include newer RDI DVLs such as pathfinder, pioneer, and tasman.
uint8 DVL_TYPE_PHASED_ARRAY=1

# Type of DVL array employed (see above).  Necessary when
# deciding how to apply sound velocity corrections
uint8 dvl_type

#################
# DVL processed #
#################

float64 altitude_sum
float64 speed_gnd
float64 course_gnd
uint8 good_beams
float64 dvl_time

####################
# DVL fixed leader #
####################

# Units: Distances [cm]; Velocities [mm/s]; Angles [deg/100]

uint8 fw_ver
uint8 fw_rev
uint32 config_khz       #75, 150, 300, or 600
uint32 carrier_frequency_hz
bool config_convex      #1 for convex, 0 for concave
uint8 config_sensornum  #1, 2, or 3
bool config_xdcr        #1 for attached, 0 for unattached
bool config_up          #1 for up, 0 for down
uint16 config_beamangle #15E, 20E, 30E, or 0 for other
uint8 config_janus      #4 for 4 beam, 5 for 5 beam demod, 15 for 5 beam 2 demod
uint8 real_sim          #0=real is default
uint8 lag
uint8 beams
uint8 cells
uint16 pings
uint16 cell_depth
uint16 blank
uint8 signal_proc       #Always =1
uint8 min_thresh
uint8 code_reps
uint8 min_good_pings
uint16 good_thresh

duration ping_interval  #Time between ping intervals
uint8 coord_mode
bool coord_tilts
bool coord_3beam
bool coord_binmapping
float64 hdng_align      #ea-command
float64 hdng_bias       #eb-command
uint8 sensor_src        #ez-command
uint8 sensor_avail      #same as sensor_src pattern
float32 bin1_dist
float32 xmit_pulse_len
uint8 avg_start
uint8 avg_end
float32 avg_false_thresh
float32 trans_lag_dist
uint8[8] serial_num_cpu
uint16 wb_cmd           #THESE ENTRIES MAY NOT BE VALID
uint8 power             #THESE ENTRIES MAY NOT BE VALID
uint32 serial_num       #THESE ENTRIES MAY NOT BE VALID
uint8 beam_angle        #THESE ENTRIES MAY NOT BE VALID


#######################
# DVL variable leader #
#######################

# Units: Hdg, Pitch, Roll [deg],  P [Pa],  dt [s],  Xdepth [m],  Cs [m/s],  S [ppt]

uint32 ensemble_num
uint8 BIT

time rtc_time           #Real-time clock for current data ensemble
uint8 rtc_year
uint8 rtc_month
uint8 rtc_day
uint8 rtc_hour
uint8 rtc_minute
uint8 rtc_second
uint8 rtc_hundredth
bool error_demod1       #flags from BIT result
bool error_demod0
bool error_timingcard
uint32 sound_vel        #ec --> m/s
float64 depth           #ed --> m
float64 heading         #eh --> degrees
float64 pitch           #ep --> degrees
float64 roll            #er --> degrees
uint16 salinity         #es -->ppm?
float64 temperature     #et -->deg C or deg F

duration mpt_wait       #Minimum prep-ping waiting time
float64 heading_std     #standard deviations
float64 pitch_std
float64 roll_std
uint8[8] adc              #analog-digital converter from dsp board

bool error_busexception #error_status_word0
bool error_address
bool error_illegalinstruction
bool error_zerodivide
bool error_emulator
bool error_unassigned
bool error_watchdogrestart
bool error_batterysaver
bool error_pinging      #error_status_word1
bool error_coldwakeup
bool error_unknwakeup
bool error_clockread    #error_status_word2
bool error_unexpectedalarm
bool error_clockforward
bool error_clockbackward
bool error_powerfail    #error_status_word3
bool error_interrupt4dsp
bool error_interrupt5uart
bool error_interrupt6clock
bool error_interrupt7
float64 pressure
float64 pressure_variance

time y2k_time           #Y2K-compliant real-time clock for current data ensemble

# Only available on pioneer
bool leak_valid
uint8 leak_status
bool leakA_detected
bool leakA_open
bool leakB_detected
bool leakB_open
uint16 leakA_raw # Raw A2D counts
uint16 leakB_raw # Raw A2D counts
float32 tx_voltage # Volts
float32 tx_current # Amps
float32 transducer_impedence # Ohms


####################
# DVL bottom track #
####################

#  All distances are in cm, velocities in mm/s, intensities in dB

uint16 pings_per_ensemble
uint16 delay
uint8 corr_mag_min
uint8 eval_amp_min
uint8 percent_good_min
uint8 mode
uint32 err_vel_max
float32[4] range
float32[4] velocity
float32[4] correlation
uint8[4] eval_amp
uint8[4] percent_good
uint32 ref_min
float32 ref_near
float32 ref_far
int32[4] ref_velocity
uint32[4] ref_correlation
float32[4] ref_intensity
uint8[4] ref_percent_good
uint16 depth_max
uint32[4] rssi_amp      #Receiver Signal Strength indicator
uint8 gain

############################
# High-resolution velocity #
############################

bool highres_valid
float32[4] highres_bt_velocity
float32[4] highres_bt_dmg
float32[4] highres_wm_velocity
float32[4] highres_wm_dmg
float32 highres_sound_vel


######################
# Bottom Track Range #
######################

bool btrange_valid
float32 btrange_slant_range
float32 btrange_axis_delta_range
float32 btrange_vertical_range
uint8 btrange_pct_good_4beam
uint8 btrange_pct_good_beam12
uint8 btrange_pct_good_beam34
float32[4] btrange_raw_range
uint8[4] btrange_max_filter
uint8[4] btrange_max_amp

#########################
# Navigation Parameters #
#########################

uint8 NAVP_BT_MODE_DEEP=0
uint8 NAVP_BT_MODE_SHALLOW=1

bool navp_valid
float32[4] navp_time_to_bottom         # seconds from trigger
float32[4] navp_bottomtrack_stddev     # m/s
float32[4] navp_bottomtrack_valid_time # seconds from trigger
uint8 navp_bottomtrack_shallow_mode
float32[4] navp_time_to_watermass      # seconds from trigger
float32[4] navp_watertrack_stddev      # m/s
float32[4] navp_watertrack_valid_time  # seconds from trigger
float32 navp_watertrack_range


================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
string frame_id

================================================================================
MSG: ds_core_msgs/DsHeader
# This is half our standard header for ds_msgs; see
# HEADERS.md for details

# This header should ALWAYS be paired with a std_msgs/Header
# and should ALWAYS reference HEADERS.md.  If you're looking at this
# file to add headers to a type, you probably want to copy/paste
# the following block:
#
#     # The standard 2-part DsHeader block
#     # This allows both a standard ROS header and DS-specific header blocks
#     # See HEADERS.md in ds_core_msgs for details
#     std_msgs/Header header
#     ds_core_msgs/DsHeader ds_header
#

# Time data was received or sent out (i/o time)
time io_time

# Sensor source UUID
uint8[16] source_uuid

"""
  # Pseudo-constants
  DVL_TYPE_PISTON = 0
  DVL_TYPE_PHASED_ARRAY = 1
  NAVP_BT_MODE_DEEP = 0
  NAVP_BT_MODE_SHALLOW = 1

  __slots__ = ['header','ds_header','dvl_type','altitude_sum','speed_gnd','course_gnd','good_beams','dvl_time','fw_ver','fw_rev','config_khz','carrier_frequency_hz','config_convex','config_sensornum','config_xdcr','config_up','config_beamangle','config_janus','real_sim','lag','beams','cells','pings','cell_depth','blank','signal_proc','min_thresh','code_reps','min_good_pings','good_thresh','ping_interval','coord_mode','coord_tilts','coord_3beam','coord_binmapping','hdng_align','hdng_bias','sensor_src','sensor_avail','bin1_dist','xmit_pulse_len','avg_start','avg_end','avg_false_thresh','trans_lag_dist','serial_num_cpu','wb_cmd','power','serial_num','beam_angle','ensemble_num','BIT','rtc_time','rtc_year','rtc_month','rtc_day','rtc_hour','rtc_minute','rtc_second','rtc_hundredth','error_demod1','error_demod0','error_timingcard','sound_vel','depth','heading','pitch','roll','salinity','temperature','mpt_wait','heading_std','pitch_std','roll_std','adc','error_busexception','error_address','error_illegalinstruction','error_zerodivide','error_emulator','error_unassigned','error_watchdogrestart','error_batterysaver','error_pinging','error_coldwakeup','error_unknwakeup','error_clockread','error_unexpectedalarm','error_clockforward','error_clockbackward','error_powerfail','error_interrupt4dsp','error_interrupt5uart','error_interrupt6clock','error_interrupt7','pressure','pressure_variance','y2k_time','leak_valid','leak_status','leakA_detected','leakA_open','leakB_detected','leakB_open','leakA_raw','leakB_raw','tx_voltage','tx_current','transducer_impedence','pings_per_ensemble','delay','corr_mag_min','eval_amp_min','percent_good_min','mode','err_vel_max','range','velocity','correlation','eval_amp','percent_good','ref_min','ref_near','ref_far','ref_velocity','ref_correlation','ref_intensity','ref_percent_good','depth_max','rssi_amp','gain','highres_valid','highres_bt_velocity','highres_bt_dmg','highres_wm_velocity','highres_wm_dmg','highres_sound_vel','btrange_valid','btrange_slant_range','btrange_axis_delta_range','btrange_vertical_range','btrange_pct_good_4beam','btrange_pct_good_beam12','btrange_pct_good_beam34','btrange_raw_range','btrange_max_filter','btrange_max_amp','navp_valid','navp_time_to_bottom','navp_bottomtrack_stddev','navp_bottomtrack_valid_time','navp_bottomtrack_shallow_mode','navp_time_to_watermass','navp_watertrack_stddev','navp_watertrack_valid_time','navp_watertrack_range']
  _slot_types = ['std_msgs/Header','ds_core_msgs/DsHeader','uint8','float64','float64','float64','uint8','float64','uint8','uint8','uint32','uint32','bool','uint8','bool','bool','uint16','uint8','uint8','uint8','uint8','uint8','uint16','uint16','uint16','uint8','uint8','uint8','uint8','uint16','duration','uint8','bool','bool','bool','float64','float64','uint8','uint8','float32','float32','uint8','uint8','float32','float32','uint8[8]','uint16','uint8','uint32','uint8','uint32','uint8','time','uint8','uint8','uint8','uint8','uint8','uint8','uint8','bool','bool','bool','uint32','float64','float64','float64','float64','uint16','float64','duration','float64','float64','float64','uint8[8]','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','float64','float64','time','bool','uint8','bool','bool','bool','bool','uint16','uint16','float32','float32','float32','uint16','uint16','uint8','uint8','uint8','uint8','uint32','float32[4]','float32[4]','float32[4]','uint8[4]','uint8[4]','uint32','float32','float32','int32[4]','uint32[4]','float32[4]','uint8[4]','uint16','uint32[4]','uint8','bool','float32[4]','float32[4]','float32[4]','float32[4]','float32','bool','float32','float32','float32','uint8','uint8','uint8','float32[4]','uint8[4]','uint8[4]','bool','float32[4]','float32[4]','float32[4]','uint8','float32[4]','float32[4]','float32[4]','float32']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       header,ds_header,dvl_type,altitude_sum,speed_gnd,course_gnd,good_beams,dvl_time,fw_ver,fw_rev,config_khz,carrier_frequency_hz,config_convex,config_sensornum,config_xdcr,config_up,config_beamangle,config_janus,real_sim,lag,beams,cells,pings,cell_depth,blank,signal_proc,min_thresh,code_reps,min_good_pings,good_thresh,ping_interval,coord_mode,coord_tilts,coord_3beam,coord_binmapping,hdng_align,hdng_bias,sensor_src,sensor_avail,bin1_dist,xmit_pulse_len,avg_start,avg_end,avg_false_thresh,trans_lag_dist,serial_num_cpu,wb_cmd,power,serial_num,beam_angle,ensemble_num,BIT,rtc_time,rtc_year,rtc_month,rtc_day,rtc_hour,rtc_minute,rtc_second,rtc_hundredth,error_demod1,error_demod0,error_timingcard,sound_vel,depth,heading,pitch,roll,salinity,temperature,mpt_wait,heading_std,pitch_std,roll_std,adc,error_busexception,error_address,error_illegalinstruction,error_zerodivide,error_emulator,error_unassigned,error_watchdogrestart,error_batterysaver,error_pinging,error_coldwakeup,error_unknwakeup,error_clockread,error_unexpectedalarm,error_clockforward,error_clockbackward,error_powerfail,error_interrupt4dsp,error_interrupt5uart,error_interrupt6clock,error_interrupt7,pressure,pressure_variance,y2k_time,leak_valid,leak_status,leakA_detected,leakA_open,leakB_detected,leakB_open,leakA_raw,leakB_raw,tx_voltage,tx_current,transducer_impedence,pings_per_ensemble,delay,corr_mag_min,eval_amp_min,percent_good_min,mode,err_vel_max,range,velocity,correlation,eval_amp,percent_good,ref_min,ref_near,ref_far,ref_velocity,ref_correlation,ref_intensity,ref_percent_good,depth_max,rssi_amp,gain,highres_valid,highres_bt_velocity,highres_bt_dmg,highres_wm_velocity,highres_wm_dmg,highres_sound_vel,btrange_valid,btrange_slant_range,btrange_axis_delta_range,btrange_vertical_range,btrange_pct_good_4beam,btrange_pct_good_beam12,btrange_pct_good_beam34,btrange_raw_range,btrange_max_filter,btrange_max_amp,navp_valid,navp_time_to_bottom,navp_bottomtrack_stddev,navp_bottomtrack_valid_time,navp_bottomtrack_shallow_mode,navp_time_to_watermass,navp_watertrack_stddev,navp_watertrack_valid_time,navp_watertrack_range

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(RdiPD0, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.ds_header is None:
        self.ds_header = ds_core_msgs.msg.DsHeader()
      if self.dvl_type is None:
        self.dvl_type = 0
      if self.altitude_sum is None:
        self.altitude_sum = 0.
      if self.speed_gnd is None:
        self.speed_gnd = 0.
      if self.course_gnd is None:
        self.course_gnd = 0.
      if self.good_beams is None:
        self.good_beams = 0
      if self.dvl_time is None:
        self.dvl_time = 0.
      if self.fw_ver is None:
        self.fw_ver = 0
      if self.fw_rev is None:
        self.fw_rev = 0
      if self.config_khz is None:
        self.config_khz = 0
      if self.carrier_frequency_hz is None:
        self.carrier_frequency_hz = 0
      if self.config_convex is None:
        self.config_convex = False
      if self.config_sensornum is None:
        self.config_sensornum = 0
      if self.config_xdcr is None:
        self.config_xdcr = False
      if self.config_up is None:
        self.config_up = False
      if self.config_beamangle is None:
        self.config_beamangle = 0
      if self.config_janus is None:
        self.config_janus = 0
      if self.real_sim is None:
        self.real_sim = 0
      if self.lag is None:
        self.lag = 0
      if self.beams is None:
        self.beams = 0
      if self.cells is None:
        self.cells = 0
      if self.pings is None:
        self.pings = 0
      if self.cell_depth is None:
        self.cell_depth = 0
      if self.blank is None:
        self.blank = 0
      if self.signal_proc is None:
        self.signal_proc = 0
      if self.min_thresh is None:
        self.min_thresh = 0
      if self.code_reps is None:
        self.code_reps = 0
      if self.min_good_pings is None:
        self.min_good_pings = 0
      if self.good_thresh is None:
        self.good_thresh = 0
      if self.ping_interval is None:
        self.ping_interval = genpy.Duration()
      if self.coord_mode is None:
        self.coord_mode = 0
      if self.coord_tilts is None:
        self.coord_tilts = False
      if self.coord_3beam is None:
        self.coord_3beam = False
      if self.coord_binmapping is None:
        self.coord_binmapping = False
      if self.hdng_align is None:
        self.hdng_align = 0.
      if self.hdng_bias is None:
        self.hdng_bias = 0.
      if self.sensor_src is None:
        self.sensor_src = 0
      if self.sensor_avail is None:
        self.sensor_avail = 0
      if self.bin1_dist is None:
        self.bin1_dist = 0.
      if self.xmit_pulse_len is None:
        self.xmit_pulse_len = 0.
      if self.avg_start is None:
        self.avg_start = 0
      if self.avg_end is None:
        self.avg_end = 0
      if self.avg_false_thresh is None:
        self.avg_false_thresh = 0.
      if self.trans_lag_dist is None:
        self.trans_lag_dist = 0.
      if self.serial_num_cpu is None:
        self.serial_num_cpu = b'\0'*8
      if self.wb_cmd is None:
        self.wb_cmd = 0
      if self.power is None:
        self.power = 0
      if self.serial_num is None:
        self.serial_num = 0
      if self.beam_angle is None:
        self.beam_angle = 0
      if self.ensemble_num is None:
        self.ensemble_num = 0
      if self.BIT is None:
        self.BIT = 0
      if self.rtc_time is None:
        self.rtc_time = genpy.Time()
      if self.rtc_year is None:
        self.rtc_year = 0
      if self.rtc_month is None:
        self.rtc_month = 0
      if self.rtc_day is None:
        self.rtc_day = 0
      if self.rtc_hour is None:
        self.rtc_hour = 0
      if self.rtc_minute is None:
        self.rtc_minute = 0
      if self.rtc_second is None:
        self.rtc_second = 0
      if self.rtc_hundredth is None:
        self.rtc_hundredth = 0
      if self.error_demod1 is None:
        self.error_demod1 = False
      if self.error_demod0 is None:
        self.error_demod0 = False
      if self.error_timingcard is None:
        self.error_timingcard = False
      if self.sound_vel is None:
        self.sound_vel = 0
      if self.depth is None:
        self.depth = 0.
      if self.heading is None:
        self.heading = 0.
      if self.pitch is None:
        self.pitch = 0.
      if self.roll is None:
        self.roll = 0.
      if self.salinity is None:
        self.salinity = 0
      if self.temperature is None:
        self.temperature = 0.
      if self.mpt_wait is None:
        self.mpt_wait = genpy.Duration()
      if self.heading_std is None:
        self.heading_std = 0.
      if self.pitch_std is None:
        self.pitch_std = 0.
      if self.roll_std is None:
        self.roll_std = 0.
      if self.adc is None:
        self.adc = b'\0'*8
      if self.error_busexception is None:
        self.error_busexception = False
      if self.error_address is None:
        self.error_address = False
      if self.error_illegalinstruction is None:
        self.error_illegalinstruction = False
      if self.error_zerodivide is None:
        self.error_zerodivide = False
      if self.error_emulator is None:
        self.error_emulator = False
      if self.error_unassigned is None:
        self.error_unassigned = False
      if self.error_watchdogrestart is None:
        self.error_watchdogrestart = False
      if self.error_batterysaver is None:
        self.error_batterysaver = False
      if self.error_pinging is None:
        self.error_pinging = False
      if self.error_coldwakeup is None:
        self.error_coldwakeup = False
      if self.error_unknwakeup is None:
        self.error_unknwakeup = False
      if self.error_clockread is None:
        self.error_clockread = False
      if self.error_unexpectedalarm is None:
        self.error_unexpectedalarm = False
      if self.error_clockforward is None:
        self.error_clockforward = False
      if self.error_clockbackward is None:
        self.error_clockbackward = False
      if self.error_powerfail is None:
        self.error_powerfail = False
      if self.error_interrupt4dsp is None:
        self.error_interrupt4dsp = False
      if self.error_interrupt5uart is None:
        self.error_interrupt5uart = False
      if self.error_interrupt6clock is None:
        self.error_interrupt6clock = False
      if self.error_interrupt7 is None:
        self.error_interrupt7 = False
      if self.pressure is None:
        self.pressure = 0.
      if self.pressure_variance is None:
        self.pressure_variance = 0.
      if self.y2k_time is None:
        self.y2k_time = genpy.Time()
      if self.leak_valid is None:
        self.leak_valid = False
      if self.leak_status is None:
        self.leak_status = 0
      if self.leakA_detected is None:
        self.leakA_detected = False
      if self.leakA_open is None:
        self.leakA_open = False
      if self.leakB_detected is None:
        self.leakB_detected = False
      if self.leakB_open is None:
        self.leakB_open = False
      if self.leakA_raw is None:
        self.leakA_raw = 0
      if self.leakB_raw is None:
        self.leakB_raw = 0
      if self.tx_voltage is None:
        self.tx_voltage = 0.
      if self.tx_current is None:
        self.tx_current = 0.
      if self.transducer_impedence is None:
        self.transducer_impedence = 0.
      if self.pings_per_ensemble is None:
        self.pings_per_ensemble = 0
      if self.delay is None:
        self.delay = 0
      if self.corr_mag_min is None:
        self.corr_mag_min = 0
      if self.eval_amp_min is None:
        self.eval_amp_min = 0
      if self.percent_good_min is None:
        self.percent_good_min = 0
      if self.mode is None:
        self.mode = 0
      if self.err_vel_max is None:
        self.err_vel_max = 0
      if self.range is None:
        self.range = [0.] * 4
      if self.velocity is None:
        self.velocity = [0.] * 4
      if self.correlation is None:
        self.correlation = [0.] * 4
      if self.eval_amp is None:
        self.eval_amp = b'\0'*4
      if self.percent_good is None:
        self.percent_good = b'\0'*4
      if self.ref_min is None:
        self.ref_min = 0
      if self.ref_near is None:
        self.ref_near = 0.
      if self.ref_far is None:
        self.ref_far = 0.
      if self.ref_velocity is None:
        self.ref_velocity = [0] * 4
      if self.ref_correlation is None:
        self.ref_correlation = [0] * 4
      if self.ref_intensity is None:
        self.ref_intensity = [0.] * 4
      if self.ref_percent_good is None:
        self.ref_percent_good = b'\0'*4
      if self.depth_max is None:
        self.depth_max = 0
      if self.rssi_amp is None:
        self.rssi_amp = [0] * 4
      if self.gain is None:
        self.gain = 0
      if self.highres_valid is None:
        self.highres_valid = False
      if self.highres_bt_velocity is None:
        self.highres_bt_velocity = [0.] * 4
      if self.highres_bt_dmg is None:
        self.highres_bt_dmg = [0.] * 4
      if self.highres_wm_velocity is None:
        self.highres_wm_velocity = [0.] * 4
      if self.highres_wm_dmg is None:
        self.highres_wm_dmg = [0.] * 4
      if self.highres_sound_vel is None:
        self.highres_sound_vel = 0.
      if self.btrange_valid is None:
        self.btrange_valid = False
      if self.btrange_slant_range is None:
        self.btrange_slant_range = 0.
      if self.btrange_axis_delta_range is None:
        self.btrange_axis_delta_range = 0.
      if self.btrange_vertical_range is None:
        self.btrange_vertical_range = 0.
      if self.btrange_pct_good_4beam is None:
        self.btrange_pct_good_4beam = 0
      if self.btrange_pct_good_beam12 is None:
        self.btrange_pct_good_beam12 = 0
      if self.btrange_pct_good_beam34 is None:
        self.btrange_pct_good_beam34 = 0
      if self.btrange_raw_range is None:
        self.btrange_raw_range = [0.] * 4
      if self.btrange_max_filter is None:
        self.btrange_max_filter = b'\0'*4
      if self.btrange_max_amp is None:
        self.btrange_max_amp = b'\0'*4
      if self.navp_valid is None:
        self.navp_valid = False
      if self.navp_time_to_bottom is None:
        self.navp_time_to_bottom = [0.] * 4
      if self.navp_bottomtrack_stddev is None:
        self.navp_bottomtrack_stddev = [0.] * 4
      if self.navp_bottomtrack_valid_time is None:
        self.navp_bottomtrack_valid_time = [0.] * 4
      if self.navp_bottomtrack_shallow_mode is None:
        self.navp_bottomtrack_shallow_mode = 0
      if self.navp_time_to_watermass is None:
        self.navp_time_to_watermass = [0.] * 4
      if self.navp_watertrack_stddev is None:
        self.navp_watertrack_stddev = [0.] * 4
      if self.navp_watertrack_valid_time is None:
        self.navp_watertrack_valid_time = [0.] * 4
      if self.navp_watertrack_range is None:
        self.navp_watertrack_range = 0.
    else:
      self.header = std_msgs.msg.Header()
      self.ds_header = ds_core_msgs.msg.DsHeader()
      self.dvl_type = 0
      self.altitude_sum = 0.
      self.speed_gnd = 0.
      self.course_gnd = 0.
      self.good_beams = 0
      self.dvl_time = 0.
      self.fw_ver = 0
      self.fw_rev = 0
      self.config_khz = 0
      self.carrier_frequency_hz = 0
      self.config_convex = False
      self.config_sensornum = 0
      self.config_xdcr = False
      self.config_up = False
      self.config_beamangle = 0
      self.config_janus = 0
      self.real_sim = 0
      self.lag = 0
      self.beams = 0
      self.cells = 0
      self.pings = 0
      self.cell_depth = 0
      self.blank = 0
      self.signal_proc = 0
      self.min_thresh = 0
      self.code_reps = 0
      self.min_good_pings = 0
      self.good_thresh = 0
      self.ping_interval = genpy.Duration()
      self.coord_mode = 0
      self.coord_tilts = False
      self.coord_3beam = False
      self.coord_binmapping = False
      self.hdng_align = 0.
      self.hdng_bias = 0.
      self.sensor_src = 0
      self.sensor_avail = 0
      self.bin1_dist = 0.
      self.xmit_pulse_len = 0.
      self.avg_start = 0
      self.avg_end = 0
      self.avg_false_thresh = 0.
      self.trans_lag_dist = 0.
      self.serial_num_cpu = b'\0'*8
      self.wb_cmd = 0
      self.power = 0
      self.serial_num = 0
      self.beam_angle = 0
      self.ensemble_num = 0
      self.BIT = 0
      self.rtc_time = genpy.Time()
      self.rtc_year = 0
      self.rtc_month = 0
      self.rtc_day = 0
      self.rtc_hour = 0
      self.rtc_minute = 0
      self.rtc_second = 0
      self.rtc_hundredth = 0
      self.error_demod1 = False
      self.error_demod0 = False
      self.error_timingcard = False
      self.sound_vel = 0
      self.depth = 0.
      self.heading = 0.
      self.pitch = 0.
      self.roll = 0.
      self.salinity = 0
      self.temperature = 0.
      self.mpt_wait = genpy.Duration()
      self.heading_std = 0.
      self.pitch_std = 0.
      self.roll_std = 0.
      self.adc = b'\0'*8
      self.error_busexception = False
      self.error_address = False
      self.error_illegalinstruction = False
      self.error_zerodivide = False
      self.error_emulator = False
      self.error_unassigned = False
      self.error_watchdogrestart = False
      self.error_batterysaver = False
      self.error_pinging = False
      self.error_coldwakeup = False
      self.error_unknwakeup = False
      self.error_clockread = False
      self.error_unexpectedalarm = False
      self.error_clockforward = False
      self.error_clockbackward = False
      self.error_powerfail = False
      self.error_interrupt4dsp = False
      self.error_interrupt5uart = False
      self.error_interrupt6clock = False
      self.error_interrupt7 = False
      self.pressure = 0.
      self.pressure_variance = 0.
      self.y2k_time = genpy.Time()
      self.leak_valid = False
      self.leak_status = 0
      self.leakA_detected = False
      self.leakA_open = False
      self.leakB_detected = False
      self.leakB_open = False
      self.leakA_raw = 0
      self.leakB_raw = 0
      self.tx_voltage = 0.
      self.tx_current = 0.
      self.transducer_impedence = 0.
      self.pings_per_ensemble = 0
      self.delay = 0
      self.corr_mag_min = 0
      self.eval_amp_min = 0
      self.percent_good_min = 0
      self.mode = 0
      self.err_vel_max = 0
      self.range = [0.] * 4
      self.velocity = [0.] * 4
      self.correlation = [0.] * 4
      self.eval_amp = b'\0'*4
      self.percent_good = b'\0'*4
      self.ref_min = 0
      self.ref_near = 0.
      self.ref_far = 0.
      self.ref_velocity = [0] * 4
      self.ref_correlation = [0] * 4
      self.ref_intensity = [0.] * 4
      self.ref_percent_good = b'\0'*4
      self.depth_max = 0
      self.rssi_amp = [0] * 4
      self.gain = 0
      self.highres_valid = False
      self.highres_bt_velocity = [0.] * 4
      self.highres_bt_dmg = [0.] * 4
      self.highres_wm_velocity = [0.] * 4
      self.highres_wm_dmg = [0.] * 4
      self.highres_sound_vel = 0.
      self.btrange_valid = False
      self.btrange_slant_range = 0.
      self.btrange_axis_delta_range = 0.
      self.btrange_vertical_range = 0.
      self.btrange_pct_good_4beam = 0
      self.btrange_pct_good_beam12 = 0
      self.btrange_pct_good_beam34 = 0
      self.btrange_raw_range = [0.] * 4
      self.btrange_max_filter = b'\0'*4
      self.btrange_max_amp = b'\0'*4
      self.navp_valid = False
      self.navp_time_to_bottom = [0.] * 4
      self.navp_bottomtrack_stddev = [0.] * 4
      self.navp_bottomtrack_valid_time = [0.] * 4
      self.navp_bottomtrack_shallow_mode = 0
      self.navp_time_to_watermass = [0.] * 4
      self.navp_watertrack_stddev = [0.] * 4
      self.navp_watertrack_valid_time = [0.] * 4
      self.navp_watertrack_range = 0.

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_2I().pack(_x.ds_header.io_time.secs, _x.ds_header.io_time.nsecs))
      _x = self.ds_header.source_uuid
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_16B().pack(*_x))
      else:
        buff.write(_get_struct_16s().pack(_x))
      _x = self
      buff.write(_get_struct_B3dBd2B2I4BH5B3H4BH2i4B2d2B2f2B2f().pack(_x.dvl_type, _x.altitude_sum, _x.speed_gnd, _x.course_gnd, _x.good_beams, _x.dvl_time, _x.fw_ver, _x.fw_rev, _x.config_khz, _x.carrier_frequency_hz, _x.config_convex, _x.config_sensornum, _x.config_xdcr, _x.config_up, _x.config_beamangle, _x.config_janus, _x.real_sim, _x.lag, _x.beams, _x.cells, _x.pings, _x.cell_depth, _x.blank, _x.signal_proc, _x.min_thresh, _x.code_reps, _x.min_good_pings, _x.good_thresh, _x.ping_interval.secs, _x.ping_interval.nsecs, _x.coord_mode, _x.coord_tilts, _x.coord_3beam, _x.coord_binmapping, _x.hdng_align, _x.hdng_bias, _x.sensor_src, _x.sensor_avail, _x.bin1_dist, _x.xmit_pulse_len, _x.avg_start, _x.avg_end, _x.avg_false_thresh, _x.trans_lag_dist))
      _x = self.serial_num_cpu
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_8B().pack(*_x))
      else:
        buff.write(_get_struct_8s().pack(_x))
      _x = self
      buff.write(_get_struct_HBIBIB2I10BI4dHd2i3d().pack(_x.wb_cmd, _x.power, _x.serial_num, _x.beam_angle, _x.ensemble_num, _x.BIT, _x.rtc_time.secs, _x.rtc_time.nsecs, _x.rtc_year, _x.rtc_month, _x.rtc_day, _x.rtc_hour, _x.rtc_minute, _x.rtc_second, _x.rtc_hundredth, _x.error_demod1, _x.error_demod0, _x.error_timingcard, _x.sound_vel, _x.depth, _x.heading, _x.pitch, _x.roll, _x.salinity, _x.temperature, _x.mpt_wait.secs, _x.mpt_wait.nsecs, _x.heading_std, _x.pitch_std, _x.roll_std))
      _x = self.adc
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_8B().pack(*_x))
      else:
        buff.write(_get_struct_8s().pack(_x))
      _x = self
      buff.write(_get_struct_20B2d2I6B2H3f2H4BI().pack(_x.error_busexception, _x.error_address, _x.error_illegalinstruction, _x.error_zerodivide, _x.error_emulator, _x.error_unassigned, _x.error_watchdogrestart, _x.error_batterysaver, _x.error_pinging, _x.error_coldwakeup, _x.error_unknwakeup, _x.error_clockread, _x.error_unexpectedalarm, _x.error_clockforward, _x.error_clockbackward, _x.error_powerfail, _x.error_interrupt4dsp, _x.error_interrupt5uart, _x.error_interrupt6clock, _x.error_interrupt7, _x.pressure, _x.pressure_variance, _x.y2k_time.secs, _x.y2k_time.nsecs, _x.leak_valid, _x.leak_status, _x.leakA_detected, _x.leakA_open, _x.leakB_detected, _x.leakB_open, _x.leakA_raw, _x.leakB_raw, _x.tx_voltage, _x.tx_current, _x.transducer_impedence, _x.pings_per_ensemble, _x.delay, _x.corr_mag_min, _x.eval_amp_min, _x.percent_good_min, _x.mode, _x.err_vel_max))
      buff.write(_get_struct_4f().pack(*self.range))
      buff.write(_get_struct_4f().pack(*self.velocity))
      buff.write(_get_struct_4f().pack(*self.correlation))
      _x = self.eval_amp
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_4B().pack(*_x))
      else:
        buff.write(_get_struct_4s().pack(_x))
      _x = self.percent_good
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_4B().pack(*_x))
      else:
        buff.write(_get_struct_4s().pack(_x))
      _x = self
      buff.write(_get_struct_I2f().pack(_x.ref_min, _x.ref_near, _x.ref_far))
      buff.write(_get_struct_4i().pack(*self.ref_velocity))
      buff.write(_get_struct_4I().pack(*self.ref_correlation))
      buff.write(_get_struct_4f().pack(*self.ref_intensity))
      _x = self.ref_percent_good
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_4B().pack(*_x))
      else:
        buff.write(_get_struct_4s().pack(_x))
      _x = self.depth_max
      buff.write(_get_struct_H().pack(_x))
      buff.write(_get_struct_4I().pack(*self.rssi_amp))
      _x = self
      buff.write(_get_struct_2B().pack(_x.gain, _x.highres_valid))
      buff.write(_get_struct_4f().pack(*self.highres_bt_velocity))
      buff.write(_get_struct_4f().pack(*self.highres_bt_dmg))
      buff.write(_get_struct_4f().pack(*self.highres_wm_velocity))
      buff.write(_get_struct_4f().pack(*self.highres_wm_dmg))
      _x = self
      buff.write(_get_struct_fB3f3B().pack(_x.highres_sound_vel, _x.btrange_valid, _x.btrange_slant_range, _x.btrange_axis_delta_range, _x.btrange_vertical_range, _x.btrange_pct_good_4beam, _x.btrange_pct_good_beam12, _x.btrange_pct_good_beam34))
      buff.write(_get_struct_4f().pack(*self.btrange_raw_range))
      _x = self.btrange_max_filter
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_4B().pack(*_x))
      else:
        buff.write(_get_struct_4s().pack(_x))
      _x = self.btrange_max_amp
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_4B().pack(*_x))
      else:
        buff.write(_get_struct_4s().pack(_x))
      _x = self.navp_valid
      buff.write(_get_struct_B().pack(_x))
      buff.write(_get_struct_4f().pack(*self.navp_time_to_bottom))
      buff.write(_get_struct_4f().pack(*self.navp_bottomtrack_stddev))
      buff.write(_get_struct_4f().pack(*self.navp_bottomtrack_valid_time))
      _x = self.navp_bottomtrack_shallow_mode
      buff.write(_get_struct_B().pack(_x))
      buff.write(_get_struct_4f().pack(*self.navp_time_to_watermass))
      buff.write(_get_struct_4f().pack(*self.navp_watertrack_stddev))
      buff.write(_get_struct_4f().pack(*self.navp_watertrack_valid_time))
      _x = self.navp_watertrack_range
      buff.write(_get_struct_f().pack(_x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.ds_header is None:
        self.ds_header = ds_core_msgs.msg.DsHeader()
      if self.ping_interval is None:
        self.ping_interval = genpy.Duration()
      if self.rtc_time is None:
        self.rtc_time = genpy.Time()
      if self.mpt_wait is None:
        self.mpt_wait = genpy.Duration()
      if self.y2k_time is None:
        self.y2k_time = genpy.Time()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 8
      (_x.ds_header.io_time.secs, _x.ds_header.io_time.nsecs,) = _get_struct_2I().unpack(str[start:end])
      start = end
      end += 16
      self.ds_header.source_uuid = str[start:end]
      _x = self
      start = end
      end += 115
      (_x.dvl_type, _x.altitude_sum, _x.speed_gnd, _x.course_gnd, _x.good_beams, _x.dvl_time, _x.fw_ver, _x.fw_rev, _x.config_khz, _x.carrier_frequency_hz, _x.config_convex, _x.config_sensornum, _x.config_xdcr, _x.config_up, _x.config_beamangle, _x.config_janus, _x.real_sim, _x.lag, _x.beams, _x.cells, _x.pings, _x.cell_depth, _x.blank, _x.signal_proc, _x.min_thresh, _x.code_reps, _x.min_good_pings, _x.good_thresh, _x.ping_interval.secs, _x.ping_interval.nsecs, _x.coord_mode, _x.coord_tilts, _x.coord_3beam, _x.coord_binmapping, _x.hdng_align, _x.hdng_bias, _x.sensor_src, _x.sensor_avail, _x.bin1_dist, _x.xmit_pulse_len, _x.avg_start, _x.avg_end, _x.avg_false_thresh, _x.trans_lag_dist,) = _get_struct_B3dBd2B2I4BH5B3H4BH2i4B2d2B2f2B2f().unpack(str[start:end])
      self.config_convex = bool(self.config_convex)
      self.config_xdcr = bool(self.config_xdcr)
      self.config_up = bool(self.config_up)
      self.coord_tilts = bool(self.coord_tilts)
      self.coord_3beam = bool(self.coord_3beam)
      self.coord_binmapping = bool(self.coord_binmapping)
      start = end
      end += 8
      self.serial_num_cpu = str[start:end]
      _x = self
      start = end
      end += 109
      (_x.wb_cmd, _x.power, _x.serial_num, _x.beam_angle, _x.ensemble_num, _x.BIT, _x.rtc_time.secs, _x.rtc_time.nsecs, _x.rtc_year, _x.rtc_month, _x.rtc_day, _x.rtc_hour, _x.rtc_minute, _x.rtc_second, _x.rtc_hundredth, _x.error_demod1, _x.error_demod0, _x.error_timingcard, _x.sound_vel, _x.depth, _x.heading, _x.pitch, _x.roll, _x.salinity, _x.temperature, _x.mpt_wait.secs, _x.mpt_wait.nsecs, _x.heading_std, _x.pitch_std, _x.roll_std,) = _get_struct_HBIBIB2I10BI4dHd2i3d().unpack(str[start:end])
      self.error_demod1 = bool(self.error_demod1)
      self.error_demod0 = bool(self.error_demod0)
      self.error_timingcard = bool(self.error_timingcard)
      start = end
      end += 8
      self.adc = str[start:end]
      _x = self
      start = end
      end += 78
      (_x.error_busexception, _x.error_address, _x.error_illegalinstruction, _x.error_zerodivide, _x.error_emulator, _x.error_unassigned, _x.error_watchdogrestart, _x.error_batterysaver, _x.error_pinging, _x.error_coldwakeup, _x.error_unknwakeup, _x.error_clockread, _x.error_unexpectedalarm, _x.error_clockforward, _x.error_clockbackward, _x.error_powerfail, _x.error_interrupt4dsp, _x.error_interrupt5uart, _x.error_interrupt6clock, _x.error_interrupt7, _x.pressure, _x.pressure_variance, _x.y2k_time.secs, _x.y2k_time.nsecs, _x.leak_valid, _x.leak_status, _x.leakA_detected, _x.leakA_open, _x.leakB_detected, _x.leakB_open, _x.leakA_raw, _x.leakB_raw, _x.tx_voltage, _x.tx_current, _x.transducer_impedence, _x.pings_per_ensemble, _x.delay, _x.corr_mag_min, _x.eval_amp_min, _x.percent_good_min, _x.mode, _x.err_vel_max,) = _get_struct_20B2d2I6B2H3f2H4BI().unpack(str[start:end])
      self.error_busexception = bool(self.error_busexception)
      self.error_address = bool(self.error_address)
      self.error_illegalinstruction = bool(self.error_illegalinstruction)
      self.error_zerodivide = bool(self.error_zerodivide)
      self.error_emulator = bool(self.error_emulator)
      self.error_unassigned = bool(self.error_unassigned)
      self.error_watchdogrestart = bool(self.error_watchdogrestart)
      self.error_batterysaver = bool(self.error_batterysaver)
      self.error_pinging = bool(self.error_pinging)
      self.error_coldwakeup = bool(self.error_coldwakeup)
      self.error_unknwakeup = bool(self.error_unknwakeup)
      self.error_clockread = bool(self.error_clockread)
      self.error_unexpectedalarm = bool(self.error_unexpectedalarm)
      self.error_clockforward = bool(self.error_clockforward)
      self.error_clockbackward = bool(self.error_clockbackward)
      self.error_powerfail = bool(self.error_powerfail)
      self.error_interrupt4dsp = bool(self.error_interrupt4dsp)
      self.error_interrupt5uart = bool(self.error_interrupt5uart)
      self.error_interrupt6clock = bool(self.error_interrupt6clock)
      self.error_interrupt7 = bool(self.error_interrupt7)
      self.leak_valid = bool(self.leak_valid)
      self.leakA_detected = bool(self.leakA_detected)
      self.leakA_open = bool(self.leakA_open)
      self.leakB_detected = bool(self.leakB_detected)
      self.leakB_open = bool(self.leakB_open)
      start = end
      end += 16
      self.range = _get_struct_4f().unpack(str[start:end])
      start = end
      end += 16
      self.velocity = _get_struct_4f().unpack(str[start:end])
      start = end
      end += 16
      self.correlation = _get_struct_4f().unpack(str[start:end])
      start = end
      end += 4
      self.eval_amp = str[start:end]
      start = end
      end += 4
      self.percent_good = str[start:end]
      _x = self
      start = end
      end += 12
      (_x.ref_min, _x.ref_near, _x.ref_far,) = _get_struct_I2f().unpack(str[start:end])
      start = end
      end += 16
      self.ref_velocity = _get_struct_4i().unpack(str[start:end])
      start = end
      end += 16
      self.ref_correlation = _get_struct_4I().unpack(str[start:end])
      start = end
      end += 16
      self.ref_intensity = _get_struct_4f().unpack(str[start:end])
      start = end
      end += 4
      self.ref_percent_good = str[start:end]
      start = end
      end += 2
      (self.depth_max,) = _get_struct_H().unpack(str[start:end])
      start = end
      end += 16
      self.rssi_amp = _get_struct_4I().unpack(str[start:end])
      _x = self
      start = end
      end += 2
      (_x.gain, _x.highres_valid,) = _get_struct_2B().unpack(str[start:end])
      self.highres_valid = bool(self.highres_valid)
      start = end
      end += 16
      self.highres_bt_velocity = _get_struct_4f().unpack(str[start:end])
      start = end
      end += 16
      self.highres_bt_dmg = _get_struct_4f().unpack(str[start:end])
      start = end
      end += 16
      self.highres_wm_velocity = _get_struct_4f().unpack(str[start:end])
      start = end
      end += 16
      self.highres_wm_dmg = _get_struct_4f().unpack(str[start:end])
      _x = self
      start = end
      end += 20
      (_x.highres_sound_vel, _x.btrange_valid, _x.btrange_slant_range, _x.btrange_axis_delta_range, _x.btrange_vertical_range, _x.btrange_pct_good_4beam, _x.btrange_pct_good_beam12, _x.btrange_pct_good_beam34,) = _get_struct_fB3f3B().unpack(str[start:end])
      self.btrange_valid = bool(self.btrange_valid)
      start = end
      end += 16
      self.btrange_raw_range = _get_struct_4f().unpack(str[start:end])
      start = end
      end += 4
      self.btrange_max_filter = str[start:end]
      start = end
      end += 4
      self.btrange_max_amp = str[start:end]
      start = end
      end += 1
      (self.navp_valid,) = _get_struct_B().unpack(str[start:end])
      self.navp_valid = bool(self.navp_valid)
      start = end
      end += 16
      self.navp_time_to_bottom = _get_struct_4f().unpack(str[start:end])
      start = end
      end += 16
      self.navp_bottomtrack_stddev = _get_struct_4f().unpack(str[start:end])
      start = end
      end += 16
      self.navp_bottomtrack_valid_time = _get_struct_4f().unpack(str[start:end])
      start = end
      end += 1
      (self.navp_bottomtrack_shallow_mode,) = _get_struct_B().unpack(str[start:end])
      start = end
      end += 16
      self.navp_time_to_watermass = _get_struct_4f().unpack(str[start:end])
      start = end
      end += 16
      self.navp_watertrack_stddev = _get_struct_4f().unpack(str[start:end])
      start = end
      end += 16
      self.navp_watertrack_valid_time = _get_struct_4f().unpack(str[start:end])
      start = end
      end += 4
      (self.navp_watertrack_range,) = _get_struct_f().unpack(str[start:end])
      self.ping_interval.canon()
      self.rtc_time.canon()
      self.mpt_wait.canon()
      self.y2k_time.canon()
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_2I().pack(_x.ds_header.io_time.secs, _x.ds_header.io_time.nsecs))
      _x = self.ds_header.source_uuid
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_16B().pack(*_x))
      else:
        buff.write(_get_struct_16s().pack(_x))
      _x = self
      buff.write(_get_struct_B3dBd2B2I4BH5B3H4BH2i4B2d2B2f2B2f().pack(_x.dvl_type, _x.altitude_sum, _x.speed_gnd, _x.course_gnd, _x.good_beams, _x.dvl_time, _x.fw_ver, _x.fw_rev, _x.config_khz, _x.carrier_frequency_hz, _x.config_convex, _x.config_sensornum, _x.config_xdcr, _x.config_up, _x.config_beamangle, _x.config_janus, _x.real_sim, _x.lag, _x.beams, _x.cells, _x.pings, _x.cell_depth, _x.blank, _x.signal_proc, _x.min_thresh, _x.code_reps, _x.min_good_pings, _x.good_thresh, _x.ping_interval.secs, _x.ping_interval.nsecs, _x.coord_mode, _x.coord_tilts, _x.coord_3beam, _x.coord_binmapping, _x.hdng_align, _x.hdng_bias, _x.sensor_src, _x.sensor_avail, _x.bin1_dist, _x.xmit_pulse_len, _x.avg_start, _x.avg_end, _x.avg_false_thresh, _x.trans_lag_dist))
      _x = self.serial_num_cpu
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_8B().pack(*_x))
      else:
        buff.write(_get_struct_8s().pack(_x))
      _x = self
      buff.write(_get_struct_HBIBIB2I10BI4dHd2i3d().pack(_x.wb_cmd, _x.power, _x.serial_num, _x.beam_angle, _x.ensemble_num, _x.BIT, _x.rtc_time.secs, _x.rtc_time.nsecs, _x.rtc_year, _x.rtc_month, _x.rtc_day, _x.rtc_hour, _x.rtc_minute, _x.rtc_second, _x.rtc_hundredth, _x.error_demod1, _x.error_demod0, _x.error_timingcard, _x.sound_vel, _x.depth, _x.heading, _x.pitch, _x.roll, _x.salinity, _x.temperature, _x.mpt_wait.secs, _x.mpt_wait.nsecs, _x.heading_std, _x.pitch_std, _x.roll_std))
      _x = self.adc
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_8B().pack(*_x))
      else:
        buff.write(_get_struct_8s().pack(_x))
      _x = self
      buff.write(_get_struct_20B2d2I6B2H3f2H4BI().pack(_x.error_busexception, _x.error_address, _x.error_illegalinstruction, _x.error_zerodivide, _x.error_emulator, _x.error_unassigned, _x.error_watchdogrestart, _x.error_batterysaver, _x.error_pinging, _x.error_coldwakeup, _x.error_unknwakeup, _x.error_clockread, _x.error_unexpectedalarm, _x.error_clockforward, _x.error_clockbackward, _x.error_powerfail, _x.error_interrupt4dsp, _x.error_interrupt5uart, _x.error_interrupt6clock, _x.error_interrupt7, _x.pressure, _x.pressure_variance, _x.y2k_time.secs, _x.y2k_time.nsecs, _x.leak_valid, _x.leak_status, _x.leakA_detected, _x.leakA_open, _x.leakB_detected, _x.leakB_open, _x.leakA_raw, _x.leakB_raw, _x.tx_voltage, _x.tx_current, _x.transducer_impedence, _x.pings_per_ensemble, _x.delay, _x.corr_mag_min, _x.eval_amp_min, _x.percent_good_min, _x.mode, _x.err_vel_max))
      buff.write(self.range.tostring())
      buff.write(self.velocity.tostring())
      buff.write(self.correlation.tostring())
      _x = self.eval_amp
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_4B().pack(*_x))
      else:
        buff.write(_get_struct_4s().pack(_x))
      _x = self.percent_good
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_4B().pack(*_x))
      else:
        buff.write(_get_struct_4s().pack(_x))
      _x = self
      buff.write(_get_struct_I2f().pack(_x.ref_min, _x.ref_near, _x.ref_far))
      buff.write(self.ref_velocity.tostring())
      buff.write(self.ref_correlation.tostring())
      buff.write(self.ref_intensity.tostring())
      _x = self.ref_percent_good
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_4B().pack(*_x))
      else:
        buff.write(_get_struct_4s().pack(_x))
      _x = self.depth_max
      buff.write(_get_struct_H().pack(_x))
      buff.write(self.rssi_amp.tostring())
      _x = self
      buff.write(_get_struct_2B().pack(_x.gain, _x.highres_valid))
      buff.write(self.highres_bt_velocity.tostring())
      buff.write(self.highres_bt_dmg.tostring())
      buff.write(self.highres_wm_velocity.tostring())
      buff.write(self.highres_wm_dmg.tostring())
      _x = self
      buff.write(_get_struct_fB3f3B().pack(_x.highres_sound_vel, _x.btrange_valid, _x.btrange_slant_range, _x.btrange_axis_delta_range, _x.btrange_vertical_range, _x.btrange_pct_good_4beam, _x.btrange_pct_good_beam12, _x.btrange_pct_good_beam34))
      buff.write(self.btrange_raw_range.tostring())
      _x = self.btrange_max_filter
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_4B().pack(*_x))
      else:
        buff.write(_get_struct_4s().pack(_x))
      _x = self.btrange_max_amp
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_4B().pack(*_x))
      else:
        buff.write(_get_struct_4s().pack(_x))
      _x = self.navp_valid
      buff.write(_get_struct_B().pack(_x))
      buff.write(self.navp_time_to_bottom.tostring())
      buff.write(self.navp_bottomtrack_stddev.tostring())
      buff.write(self.navp_bottomtrack_valid_time.tostring())
      _x = self.navp_bottomtrack_shallow_mode
      buff.write(_get_struct_B().pack(_x))
      buff.write(self.navp_time_to_watermass.tostring())
      buff.write(self.navp_watertrack_stddev.tostring())
      buff.write(self.navp_watertrack_valid_time.tostring())
      _x = self.navp_watertrack_range
      buff.write(_get_struct_f().pack(_x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.ds_header is None:
        self.ds_header = ds_core_msgs.msg.DsHeader()
      if self.ping_interval is None:
        self.ping_interval = genpy.Duration()
      if self.rtc_time is None:
        self.rtc_time = genpy.Time()
      if self.mpt_wait is None:
        self.mpt_wait = genpy.Duration()
      if self.y2k_time is None:
        self.y2k_time = genpy.Time()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 8
      (_x.ds_header.io_time.secs, _x.ds_header.io_time.nsecs,) = _get_struct_2I().unpack(str[start:end])
      start = end
      end += 16
      self.ds_header.source_uuid = str[start:end]
      _x = self
      start = end
      end += 115
      (_x.dvl_type, _x.altitude_sum, _x.speed_gnd, _x.course_gnd, _x.good_beams, _x.dvl_time, _x.fw_ver, _x.fw_rev, _x.config_khz, _x.carrier_frequency_hz, _x.config_convex, _x.config_sensornum, _x.config_xdcr, _x.config_up, _x.config_beamangle, _x.config_janus, _x.real_sim, _x.lag, _x.beams, _x.cells, _x.pings, _x.cell_depth, _x.blank, _x.signal_proc, _x.min_thresh, _x.code_reps, _x.min_good_pings, _x.good_thresh, _x.ping_interval.secs, _x.ping_interval.nsecs, _x.coord_mode, _x.coord_tilts, _x.coord_3beam, _x.coord_binmapping, _x.hdng_align, _x.hdng_bias, _x.sensor_src, _x.sensor_avail, _x.bin1_dist, _x.xmit_pulse_len, _x.avg_start, _x.avg_end, _x.avg_false_thresh, _x.trans_lag_dist,) = _get_struct_B3dBd2B2I4BH5B3H4BH2i4B2d2B2f2B2f().unpack(str[start:end])
      self.config_convex = bool(self.config_convex)
      self.config_xdcr = bool(self.config_xdcr)
      self.config_up = bool(self.config_up)
      self.coord_tilts = bool(self.coord_tilts)
      self.coord_3beam = bool(self.coord_3beam)
      self.coord_binmapping = bool(self.coord_binmapping)
      start = end
      end += 8
      self.serial_num_cpu = str[start:end]
      _x = self
      start = end
      end += 109
      (_x.wb_cmd, _x.power, _x.serial_num, _x.beam_angle, _x.ensemble_num, _x.BIT, _x.rtc_time.secs, _x.rtc_time.nsecs, _x.rtc_year, _x.rtc_month, _x.rtc_day, _x.rtc_hour, _x.rtc_minute, _x.rtc_second, _x.rtc_hundredth, _x.error_demod1, _x.error_demod0, _x.error_timingcard, _x.sound_vel, _x.depth, _x.heading, _x.pitch, _x.roll, _x.salinity, _x.temperature, _x.mpt_wait.secs, _x.mpt_wait.nsecs, _x.heading_std, _x.pitch_std, _x.roll_std,) = _get_struct_HBIBIB2I10BI4dHd2i3d().unpack(str[start:end])
      self.error_demod1 = bool(self.error_demod1)
      self.error_demod0 = bool(self.error_demod0)
      self.error_timingcard = bool(self.error_timingcard)
      start = end
      end += 8
      self.adc = str[start:end]
      _x = self
      start = end
      end += 78
      (_x.error_busexception, _x.error_address, _x.error_illegalinstruction, _x.error_zerodivide, _x.error_emulator, _x.error_unassigned, _x.error_watchdogrestart, _x.error_batterysaver, _x.error_pinging, _x.error_coldwakeup, _x.error_unknwakeup, _x.error_clockread, _x.error_unexpectedalarm, _x.error_clockforward, _x.error_clockbackward, _x.error_powerfail, _x.error_interrupt4dsp, _x.error_interrupt5uart, _x.error_interrupt6clock, _x.error_interrupt7, _x.pressure, _x.pressure_variance, _x.y2k_time.secs, _x.y2k_time.nsecs, _x.leak_valid, _x.leak_status, _x.leakA_detected, _x.leakA_open, _x.leakB_detected, _x.leakB_open, _x.leakA_raw, _x.leakB_raw, _x.tx_voltage, _x.tx_current, _x.transducer_impedence, _x.pings_per_ensemble, _x.delay, _x.corr_mag_min, _x.eval_amp_min, _x.percent_good_min, _x.mode, _x.err_vel_max,) = _get_struct_20B2d2I6B2H3f2H4BI().unpack(str[start:end])
      self.error_busexception = bool(self.error_busexception)
      self.error_address = bool(self.error_address)
      self.error_illegalinstruction = bool(self.error_illegalinstruction)
      self.error_zerodivide = bool(self.error_zerodivide)
      self.error_emulator = bool(self.error_emulator)
      self.error_unassigned = bool(self.error_unassigned)
      self.error_watchdogrestart = bool(self.error_watchdogrestart)
      self.error_batterysaver = bool(self.error_batterysaver)
      self.error_pinging = bool(self.error_pinging)
      self.error_coldwakeup = bool(self.error_coldwakeup)
      self.error_unknwakeup = bool(self.error_unknwakeup)
      self.error_clockread = bool(self.error_clockread)
      self.error_unexpectedalarm = bool(self.error_unexpectedalarm)
      self.error_clockforward = bool(self.error_clockforward)
      self.error_clockbackward = bool(self.error_clockbackward)
      self.error_powerfail = bool(self.error_powerfail)
      self.error_interrupt4dsp = bool(self.error_interrupt4dsp)
      self.error_interrupt5uart = bool(self.error_interrupt5uart)
      self.error_interrupt6clock = bool(self.error_interrupt6clock)
      self.error_interrupt7 = bool(self.error_interrupt7)
      self.leak_valid = bool(self.leak_valid)
      self.leakA_detected = bool(self.leakA_detected)
      self.leakA_open = bool(self.leakA_open)
      self.leakB_detected = bool(self.leakB_detected)
      self.leakB_open = bool(self.leakB_open)
      start = end
      end += 16
      self.range = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=4)
      start = end
      end += 16
      self.velocity = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=4)
      start = end
      end += 16
      self.correlation = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=4)
      start = end
      end += 4
      self.eval_amp = str[start:end]
      start = end
      end += 4
      self.percent_good = str[start:end]
      _x = self
      start = end
      end += 12
      (_x.ref_min, _x.ref_near, _x.ref_far,) = _get_struct_I2f().unpack(str[start:end])
      start = end
      end += 16
      self.ref_velocity = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=4)
      start = end
      end += 16
      self.ref_correlation = numpy.frombuffer(str[start:end], dtype=numpy.uint32, count=4)
      start = end
      end += 16
      self.ref_intensity = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=4)
      start = end
      end += 4
      self.ref_percent_good = str[start:end]
      start = end
      end += 2
      (self.depth_max,) = _get_struct_H().unpack(str[start:end])
      start = end
      end += 16
      self.rssi_amp = numpy.frombuffer(str[start:end], dtype=numpy.uint32, count=4)
      _x = self
      start = end
      end += 2
      (_x.gain, _x.highres_valid,) = _get_struct_2B().unpack(str[start:end])
      self.highres_valid = bool(self.highres_valid)
      start = end
      end += 16
      self.highres_bt_velocity = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=4)
      start = end
      end += 16
      self.highres_bt_dmg = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=4)
      start = end
      end += 16
      self.highres_wm_velocity = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=4)
      start = end
      end += 16
      self.highres_wm_dmg = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=4)
      _x = self
      start = end
      end += 20
      (_x.highres_sound_vel, _x.btrange_valid, _x.btrange_slant_range, _x.btrange_axis_delta_range, _x.btrange_vertical_range, _x.btrange_pct_good_4beam, _x.btrange_pct_good_beam12, _x.btrange_pct_good_beam34,) = _get_struct_fB3f3B().unpack(str[start:end])
      self.btrange_valid = bool(self.btrange_valid)
      start = end
      end += 16
      self.btrange_raw_range = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=4)
      start = end
      end += 4
      self.btrange_max_filter = str[start:end]
      start = end
      end += 4
      self.btrange_max_amp = str[start:end]
      start = end
      end += 1
      (self.navp_valid,) = _get_struct_B().unpack(str[start:end])
      self.navp_valid = bool(self.navp_valid)
      start = end
      end += 16
      self.navp_time_to_bottom = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=4)
      start = end
      end += 16
      self.navp_bottomtrack_stddev = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=4)
      start = end
      end += 16
      self.navp_bottomtrack_valid_time = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=4)
      start = end
      end += 1
      (self.navp_bottomtrack_shallow_mode,) = _get_struct_B().unpack(str[start:end])
      start = end
      end += 16
      self.navp_time_to_watermass = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=4)
      start = end
      end += 16
      self.navp_watertrack_stddev = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=4)
      start = end
      end += 16
      self.navp_watertrack_valid_time = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=4)
      start = end
      end += 4
      (self.navp_watertrack_range,) = _get_struct_f().unpack(str[start:end])
      self.ping_interval.canon()
      self.rtc_time.canon()
      self.mpt_wait.canon()
      self.y2k_time.canon()
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_16B = None
def _get_struct_16B():
    global _struct_16B
    if _struct_16B is None:
        _struct_16B = struct.Struct("<16B")
    return _struct_16B
_struct_16s = None
def _get_struct_16s():
    global _struct_16s
    if _struct_16s is None:
        _struct_16s = struct.Struct("<16s")
    return _struct_16s
_struct_20B2d2I6B2H3f2H4BI = None
def _get_struct_20B2d2I6B2H3f2H4BI():
    global _struct_20B2d2I6B2H3f2H4BI
    if _struct_20B2d2I6B2H3f2H4BI is None:
        _struct_20B2d2I6B2H3f2H4BI = struct.Struct("<20B2d2I6B2H3f2H4BI")
    return _struct_20B2d2I6B2H3f2H4BI
_struct_2B = None
def _get_struct_2B():
    global _struct_2B
    if _struct_2B is None:
        _struct_2B = struct.Struct("<2B")
    return _struct_2B
_struct_2I = None
def _get_struct_2I():
    global _struct_2I
    if _struct_2I is None:
        _struct_2I = struct.Struct("<2I")
    return _struct_2I
_struct_3I = None
def _get_struct_3I():
    global _struct_3I
    if _struct_3I is None:
        _struct_3I = struct.Struct("<3I")
    return _struct_3I
_struct_4B = None
def _get_struct_4B():
    global _struct_4B
    if _struct_4B is None:
        _struct_4B = struct.Struct("<4B")
    return _struct_4B
_struct_4I = None
def _get_struct_4I():
    global _struct_4I
    if _struct_4I is None:
        _struct_4I = struct.Struct("<4I")
    return _struct_4I
_struct_4f = None
def _get_struct_4f():
    global _struct_4f
    if _struct_4f is None:
        _struct_4f = struct.Struct("<4f")
    return _struct_4f
_struct_4i = None
def _get_struct_4i():
    global _struct_4i
    if _struct_4i is None:
        _struct_4i = struct.Struct("<4i")
    return _struct_4i
_struct_4s = None
def _get_struct_4s():
    global _struct_4s
    if _struct_4s is None:
        _struct_4s = struct.Struct("<4s")
    return _struct_4s
_struct_8B = None
def _get_struct_8B():
    global _struct_8B
    if _struct_8B is None:
        _struct_8B = struct.Struct("<8B")
    return _struct_8B
_struct_8s = None
def _get_struct_8s():
    global _struct_8s
    if _struct_8s is None:
        _struct_8s = struct.Struct("<8s")
    return _struct_8s
_struct_B = None
def _get_struct_B():
    global _struct_B
    if _struct_B is None:
        _struct_B = struct.Struct("<B")
    return _struct_B
_struct_B3dBd2B2I4BH5B3H4BH2i4B2d2B2f2B2f = None
def _get_struct_B3dBd2B2I4BH5B3H4BH2i4B2d2B2f2B2f():
    global _struct_B3dBd2B2I4BH5B3H4BH2i4B2d2B2f2B2f
    if _struct_B3dBd2B2I4BH5B3H4BH2i4B2d2B2f2B2f is None:
        _struct_B3dBd2B2I4BH5B3H4BH2i4B2d2B2f2B2f = struct.Struct("<B3dBd2B2I4BH5B3H4BH2i4B2d2B2f2B2f")
    return _struct_B3dBd2B2I4BH5B3H4BH2i4B2d2B2f2B2f
_struct_H = None
def _get_struct_H():
    global _struct_H
    if _struct_H is None:
        _struct_H = struct.Struct("<H")
    return _struct_H
_struct_HBIBIB2I10BI4dHd2i3d = None
def _get_struct_HBIBIB2I10BI4dHd2i3d():
    global _struct_HBIBIB2I10BI4dHd2i3d
    if _struct_HBIBIB2I10BI4dHd2i3d is None:
        _struct_HBIBIB2I10BI4dHd2i3d = struct.Struct("<HBIBIB2I10BI4dHd2i3d")
    return _struct_HBIBIB2I10BI4dHd2i3d
_struct_I2f = None
def _get_struct_I2f():
    global _struct_I2f
    if _struct_I2f is None:
        _struct_I2f = struct.Struct("<I2f")
    return _struct_I2f
_struct_f = None
def _get_struct_f():
    global _struct_f
    if _struct_f is None:
        _struct_f = struct.Struct("<f")
    return _struct_f
_struct_fB3f3B = None
def _get_struct_fB3f3B():
    global _struct_fB3f3B
    if _struct_fB3f3B is None:
        _struct_fB3f3B = struct.Struct("<fB3f3B")
    return _struct_fB3f3B
