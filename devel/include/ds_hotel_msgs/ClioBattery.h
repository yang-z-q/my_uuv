// Generated by gencpp from file ds_hotel_msgs/ClioBattery.msg
// DO NOT EDIT!


#ifndef DS_HOTEL_MSGS_MESSAGE_CLIOBATTERY_H
#define DS_HOTEL_MSGS_MESSAGE_CLIOBATTERY_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>
#include <ds_core_msgs/DsHeader.h>
#include <ds_hotel_msgs/ClioBatteryPack.h>

namespace ds_hotel_msgs
{
template <class ContainerAllocator>
struct ClioBattery_
{
  typedef ClioBattery_<ContainerAllocator> Type;

  ClioBattery_()
    : header()
    , ds_header()
    , busAddress(0)
    , version(0)
    , date()
    , startupCondition(0)
    , uptime(0)
    , overflowCount(0)
    , timeoutCount(0)
    , powerswitchState(0)
    , chargetimeRemaining(0)
    , chargetimeMax(0)
    , moduleStatus(0)
    , packs()
    , maxPackTemp(0.0)
    , minPackTemp(0.0)
    , maxPackVoltage(0.0)
    , minPackVoltage(0.0)
    , minCellVoltage(0.0)
    , maxCellVoltage(0.0)
    , moduleVoltage(0.0)
    , chargeEnabled(false)
    , charging(false)
    , discharging(false)
    , remainingCapacity(0.0)
    , fullCapacity(0.0)
    , designCapacity(0.0)
    , percentFull(0.0)  {
    }
  ClioBattery_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , ds_header(_alloc)
    , busAddress(0)
    , version(0)
    , date(_alloc)
    , startupCondition(0)
    , uptime(0)
    , overflowCount(0)
    , timeoutCount(0)
    , powerswitchState(0)
    , chargetimeRemaining(0)
    , chargetimeMax(0)
    , moduleStatus(0)
    , packs(_alloc)
    , maxPackTemp(0.0)
    , minPackTemp(0.0)
    , maxPackVoltage(0.0)
    , minPackVoltage(0.0)
    , minCellVoltage(0.0)
    , maxCellVoltage(0.0)
    , moduleVoltage(0.0)
    , chargeEnabled(false)
    , charging(false)
    , discharging(false)
    , remainingCapacity(0.0)
    , fullCapacity(0.0)
    , designCapacity(0.0)
    , percentFull(0.0)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef  ::ds_core_msgs::DsHeader_<ContainerAllocator>  _ds_header_type;
  _ds_header_type ds_header;

   typedef uint16_t _busAddress_type;
  _busAddress_type busAddress;

   typedef uint16_t _version_type;
  _version_type version;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _date_type;
  _date_type date;

   typedef uint16_t _startupCondition_type;
  _startupCondition_type startupCondition;

   typedef uint16_t _uptime_type;
  _uptime_type uptime;

   typedef uint16_t _overflowCount_type;
  _overflowCount_type overflowCount;

   typedef uint16_t _timeoutCount_type;
  _timeoutCount_type timeoutCount;

   typedef uint16_t _powerswitchState_type;
  _powerswitchState_type powerswitchState;

   typedef uint16_t _chargetimeRemaining_type;
  _chargetimeRemaining_type chargetimeRemaining;

   typedef uint16_t _chargetimeMax_type;
  _chargetimeMax_type chargetimeMax;

   typedef uint16_t _moduleStatus_type;
  _moduleStatus_type moduleStatus;

   typedef std::vector< ::ds_hotel_msgs::ClioBatteryPack_<ContainerAllocator> , typename std::allocator_traits<ContainerAllocator>::template rebind_alloc< ::ds_hotel_msgs::ClioBatteryPack_<ContainerAllocator> >> _packs_type;
  _packs_type packs;

   typedef float _maxPackTemp_type;
  _maxPackTemp_type maxPackTemp;

   typedef float _minPackTemp_type;
  _minPackTemp_type minPackTemp;

   typedef float _maxPackVoltage_type;
  _maxPackVoltage_type maxPackVoltage;

   typedef float _minPackVoltage_type;
  _minPackVoltage_type minPackVoltage;

   typedef float _minCellVoltage_type;
  _minCellVoltage_type minCellVoltage;

   typedef float _maxCellVoltage_type;
  _maxCellVoltage_type maxCellVoltage;

   typedef float _moduleVoltage_type;
  _moduleVoltage_type moduleVoltage;

   typedef uint8_t _chargeEnabled_type;
  _chargeEnabled_type chargeEnabled;

   typedef uint8_t _charging_type;
  _charging_type charging;

   typedef uint8_t _discharging_type;
  _discharging_type discharging;

   typedef float _remainingCapacity_type;
  _remainingCapacity_type remainingCapacity;

   typedef float _fullCapacity_type;
  _fullCapacity_type fullCapacity;

   typedef float _designCapacity_type;
  _designCapacity_type designCapacity;

   typedef double _percentFull_type;
  _percentFull_type percentFull;





  typedef boost::shared_ptr< ::ds_hotel_msgs::ClioBattery_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::ds_hotel_msgs::ClioBattery_<ContainerAllocator> const> ConstPtr;

}; // struct ClioBattery_

typedef ::ds_hotel_msgs::ClioBattery_<std::allocator<void> > ClioBattery;

typedef boost::shared_ptr< ::ds_hotel_msgs::ClioBattery > ClioBatteryPtr;
typedef boost::shared_ptr< ::ds_hotel_msgs::ClioBattery const> ClioBatteryConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::ds_hotel_msgs::ClioBattery_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::ds_hotel_msgs::ClioBattery_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::ds_hotel_msgs::ClioBattery_<ContainerAllocator1> & lhs, const ::ds_hotel_msgs::ClioBattery_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.ds_header == rhs.ds_header &&
    lhs.busAddress == rhs.busAddress &&
    lhs.version == rhs.version &&
    lhs.date == rhs.date &&
    lhs.startupCondition == rhs.startupCondition &&
    lhs.uptime == rhs.uptime &&
    lhs.overflowCount == rhs.overflowCount &&
    lhs.timeoutCount == rhs.timeoutCount &&
    lhs.powerswitchState == rhs.powerswitchState &&
    lhs.chargetimeRemaining == rhs.chargetimeRemaining &&
    lhs.chargetimeMax == rhs.chargetimeMax &&
    lhs.moduleStatus == rhs.moduleStatus &&
    lhs.packs == rhs.packs &&
    lhs.maxPackTemp == rhs.maxPackTemp &&
    lhs.minPackTemp == rhs.minPackTemp &&
    lhs.maxPackVoltage == rhs.maxPackVoltage &&
    lhs.minPackVoltage == rhs.minPackVoltage &&
    lhs.minCellVoltage == rhs.minCellVoltage &&
    lhs.maxCellVoltage == rhs.maxCellVoltage &&
    lhs.moduleVoltage == rhs.moduleVoltage &&
    lhs.chargeEnabled == rhs.chargeEnabled &&
    lhs.charging == rhs.charging &&
    lhs.discharging == rhs.discharging &&
    lhs.remainingCapacity == rhs.remainingCapacity &&
    lhs.fullCapacity == rhs.fullCapacity &&
    lhs.designCapacity == rhs.designCapacity &&
    lhs.percentFull == rhs.percentFull;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::ds_hotel_msgs::ClioBattery_<ContainerAllocator1> & lhs, const ::ds_hotel_msgs::ClioBattery_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace ds_hotel_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::ds_hotel_msgs::ClioBattery_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::ds_hotel_msgs::ClioBattery_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::ds_hotel_msgs::ClioBattery_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::ds_hotel_msgs::ClioBattery_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::ds_hotel_msgs::ClioBattery_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::ds_hotel_msgs::ClioBattery_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::ds_hotel_msgs::ClioBattery_<ContainerAllocator> >
{
  static const char* value()
  {
    return "6081c20afa69fa62591d000307450350";
  }

  static const char* value(const ::ds_hotel_msgs::ClioBattery_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x6081c20afa69fa62ULL;
  static const uint64_t static_value2 = 0x591d000307450350ULL;
};

template<class ContainerAllocator>
struct DataType< ::ds_hotel_msgs::ClioBattery_<ContainerAllocator> >
{
  static const char* value()
  {
    return "ds_hotel_msgs/ClioBattery";
  }

  static const char* value(const ::ds_hotel_msgs::ClioBattery_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::ds_hotel_msgs::ClioBattery_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# The standard 2-part DsHeader block\n"
"# This allows both a standard ROS header and DS-specific header blocks\n"
"# See HEADERS.md in ds_core_msgs for details\n"
"std_msgs/Header header\n"
"ds_core_msgs/DsHeader ds_header\n"
"\n"
"uint16 busAddress\n"
"uint16 version\n"
"string date\n"
"uint16 startupCondition\n"
"uint16 uptime\n"
"uint16 overflowCount\n"
"uint16 timeoutCount\n"
"uint16 powerswitchState\n"
"uint16 chargetimeRemaining\n"
"uint16 chargetimeMax\n"
"uint16 moduleStatus # Bitwise OR of status fields from all batteries\n"
"\n"
"ClioBatteryPack[] packs\n"
"\n"
"## Calculated\n"
"float32 maxPackTemp\n"
"float32 minPackTemp\n"
"float32 maxPackVoltage\n"
"float32 minPackVoltage\n"
"float32 minCellVoltage\n"
"float32 maxCellVoltage\n"
"float32 moduleVoltage #V\n"
"bool chargeEnabled\n"
"bool charging\n"
"bool discharging\n"
"float32 remainingCapacity # Remaining capacity, in Amp Hours\n"
"float32 fullCapacity # Predicted capacity when full, in Amp Hours\n"
"float32 designCapacity # Design capacity, in Amp Hours\n"
"float64 percentFull # Battery capacity as a percentage.  Local capacity\n"
"\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
"\n"
"================================================================================\n"
"MSG: ds_core_msgs/DsHeader\n"
"# This is half our standard header for ds_msgs; see\n"
"# HEADERS.md for details\n"
"\n"
"# This header should ALWAYS be paired with a std_msgs/Header\n"
"# and should ALWAYS reference HEADERS.md.  If you're looking at this\n"
"# file to add headers to a type, you probably want to copy/paste\n"
"# the following block:\n"
"#\n"
"#     # The standard 2-part DsHeader block\n"
"#     # This allows both a standard ROS header and DS-specific header blocks\n"
"#     # See HEADERS.md in ds_core_msgs for details\n"
"#     std_msgs/Header header\n"
"#     ds_core_msgs/DsHeader ds_header\n"
"#\n"
"\n"
"# Time data was received or sent out (i/o time)\n"
"time io_time\n"
"\n"
"# Sensor source UUID\n"
"uint8[16] source_uuid\n"
"\n"
"\n"
"================================================================================\n"
"MSG: ds_hotel_msgs/ClioBatteryPack\n"
"# Per-pack\n"
"float32 temperature # deg C\n"
"float32 voltage # V\n"
"float32 current\n"
"float32 avgCurrent\n"
"uint16 maxError\n"
"float32 relativeSOC # percent\n"
"float32 absoluteSOC # percent\n"
"float32 remainingCapacity # Remaining capacity in Amp*hours\n"
"float32 fullCapacity # Predicted capacity when fully charged in Amp*hours\n"
"uint16 status\n"
"float32 countCycle\n"
"float32 capacityDesign\n"
"string dateManufacture\n"
"uint16 serialNumber\n"
"# high / mid / low refer to the arrangement of cells within \n"
"# the pack, NOT to which has the highest voltage\n"
"float32 highCellVoltage\n"
"float32 mid1CellVoltage\n"
"float32 mid2CellVoltage\n"
"float32 lowCellVoltage\n"
"\n"
;
  }

  static const char* value(const ::ds_hotel_msgs::ClioBattery_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::ds_hotel_msgs::ClioBattery_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.ds_header);
      stream.next(m.busAddress);
      stream.next(m.version);
      stream.next(m.date);
      stream.next(m.startupCondition);
      stream.next(m.uptime);
      stream.next(m.overflowCount);
      stream.next(m.timeoutCount);
      stream.next(m.powerswitchState);
      stream.next(m.chargetimeRemaining);
      stream.next(m.chargetimeMax);
      stream.next(m.moduleStatus);
      stream.next(m.packs);
      stream.next(m.maxPackTemp);
      stream.next(m.minPackTemp);
      stream.next(m.maxPackVoltage);
      stream.next(m.minPackVoltage);
      stream.next(m.minCellVoltage);
      stream.next(m.maxCellVoltage);
      stream.next(m.moduleVoltage);
      stream.next(m.chargeEnabled);
      stream.next(m.charging);
      stream.next(m.discharging);
      stream.next(m.remainingCapacity);
      stream.next(m.fullCapacity);
      stream.next(m.designCapacity);
      stream.next(m.percentFull);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct ClioBattery_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::ds_hotel_msgs::ClioBattery_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::ds_hotel_msgs::ClioBattery_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "ds_header: ";
    s << std::endl;
    Printer< ::ds_core_msgs::DsHeader_<ContainerAllocator> >::stream(s, indent + "  ", v.ds_header);
    s << indent << "busAddress: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.busAddress);
    s << indent << "version: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.version);
    s << indent << "date: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.date);
    s << indent << "startupCondition: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.startupCondition);
    s << indent << "uptime: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.uptime);
    s << indent << "overflowCount: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.overflowCount);
    s << indent << "timeoutCount: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.timeoutCount);
    s << indent << "powerswitchState: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.powerswitchState);
    s << indent << "chargetimeRemaining: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.chargetimeRemaining);
    s << indent << "chargetimeMax: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.chargetimeMax);
    s << indent << "moduleStatus: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.moduleStatus);
    s << indent << "packs[]" << std::endl;
    for (size_t i = 0; i < v.packs.size(); ++i)
    {
      s << indent << "  packs[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::ds_hotel_msgs::ClioBatteryPack_<ContainerAllocator> >::stream(s, indent + "    ", v.packs[i]);
    }
    s << indent << "maxPackTemp: ";
    Printer<float>::stream(s, indent + "  ", v.maxPackTemp);
    s << indent << "minPackTemp: ";
    Printer<float>::stream(s, indent + "  ", v.minPackTemp);
    s << indent << "maxPackVoltage: ";
    Printer<float>::stream(s, indent + "  ", v.maxPackVoltage);
    s << indent << "minPackVoltage: ";
    Printer<float>::stream(s, indent + "  ", v.minPackVoltage);
    s << indent << "minCellVoltage: ";
    Printer<float>::stream(s, indent + "  ", v.minCellVoltage);
    s << indent << "maxCellVoltage: ";
    Printer<float>::stream(s, indent + "  ", v.maxCellVoltage);
    s << indent << "moduleVoltage: ";
    Printer<float>::stream(s, indent + "  ", v.moduleVoltage);
    s << indent << "chargeEnabled: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.chargeEnabled);
    s << indent << "charging: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.charging);
    s << indent << "discharging: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.discharging);
    s << indent << "remainingCapacity: ";
    Printer<float>::stream(s, indent + "  ", v.remainingCapacity);
    s << indent << "fullCapacity: ";
    Printer<float>::stream(s, indent + "  ", v.fullCapacity);
    s << indent << "designCapacity: ";
    Printer<float>::stream(s, indent + "  ", v.designCapacity);
    s << indent << "percentFull: ";
    Printer<double>::stream(s, indent + "  ", v.percentFull);
  }
};

} // namespace message_operations
} // namespace ros

#endif // DS_HOTEL_MSGS_MESSAGE_CLIOBATTERY_H
