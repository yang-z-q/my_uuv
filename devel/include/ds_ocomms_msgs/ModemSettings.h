// Generated by gencpp from file ds_ocomms_msgs/ModemSettings.msg
// DO NOT EDIT!


#ifndef DS_OCOMMS_MSGS_MESSAGE_MODEMSETTINGS_H
#define DS_OCOMMS_MSGS_MESSAGE_MODEMSETTINGS_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>
#include <ds_core_msgs/DsHeader.h>

namespace ds_ocomms_msgs
{
template <class ContainerAllocator>
struct ModemSettings_
{
  typedef ModemSettings_<ContainerAllocator> Type;

  ModemSettings_()
    : header()
    , ds_header()
    , ip_addr()
    , netmask()
    , brdcst()
    , dfltgw()
    , dfltip()
    , dflmac()
    , dflprt(0.0)
    , laripa()
    , larmac()
    , larprt(0.0)
    , lfpipa()
    , lfpmac()
    , lfpprt(0.0)
    , remipa()
    , raripa()
    , rarmac()
    , rsubnt()
    , brdgen(0)
    , brdgip()
    , guiipa()
    , fpg3vr()
    , fpg6vr()
    , softvr()
    , reboot(0)
    , dfmode(0)
    , master_slaven(0)
    , logena(0)
    , acsten(0)
    , acstmast_slaven(0)
    , acstmfg(0)
    , lamdid(0)
    , ramdid(0)
    , sensitivity_ctrl(0)
    , lrhaln(0)
    , status1hz_enable(0)  {
    }
  ModemSettings_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , ds_header(_alloc)
    , ip_addr(_alloc)
    , netmask(_alloc)
    , brdcst(_alloc)
    , dfltgw(_alloc)
    , dfltip(_alloc)
    , dflmac(_alloc)
    , dflprt(0.0)
    , laripa(_alloc)
    , larmac(_alloc)
    , larprt(0.0)
    , lfpipa(_alloc)
    , lfpmac(_alloc)
    , lfpprt(0.0)
    , remipa(_alloc)
    , raripa(_alloc)
    , rarmac(_alloc)
    , rsubnt(_alloc)
    , brdgen(0)
    , brdgip(_alloc)
    , guiipa(_alloc)
    , fpg3vr(_alloc)
    , fpg6vr(_alloc)
    , softvr(_alloc)
    , reboot(0)
    , dfmode(0)
    , master_slaven(0)
    , logena(0)
    , acsten(0)
    , acstmast_slaven(0)
    , acstmfg(0)
    , lamdid(0)
    , ramdid(0)
    , sensitivity_ctrl(0)
    , lrhaln(0)
    , status1hz_enable(0)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef  ::ds_core_msgs::DsHeader_<ContainerAllocator>  _ds_header_type;
  _ds_header_type ds_header;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _ip_addr_type;
  _ip_addr_type ip_addr;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _netmask_type;
  _netmask_type netmask;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _brdcst_type;
  _brdcst_type brdcst;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _dfltgw_type;
  _dfltgw_type dfltgw;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _dfltip_type;
  _dfltip_type dfltip;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _dflmac_type;
  _dflmac_type dflmac;

   typedef double _dflprt_type;
  _dflprt_type dflprt;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _laripa_type;
  _laripa_type laripa;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _larmac_type;
  _larmac_type larmac;

   typedef double _larprt_type;
  _larprt_type larprt;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _lfpipa_type;
  _lfpipa_type lfpipa;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _lfpmac_type;
  _lfpmac_type lfpmac;

   typedef double _lfpprt_type;
  _lfpprt_type lfpprt;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _remipa_type;
  _remipa_type remipa;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _raripa_type;
  _raripa_type raripa;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _rarmac_type;
  _rarmac_type rarmac;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _rsubnt_type;
  _rsubnt_type rsubnt;

   typedef uint16_t _brdgen_type;
  _brdgen_type brdgen;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _brdgip_type;
  _brdgip_type brdgip;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _guiipa_type;
  _guiipa_type guiipa;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _fpg3vr_type;
  _fpg3vr_type fpg3vr;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _fpg6vr_type;
  _fpg6vr_type fpg6vr;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _softvr_type;
  _softvr_type softvr;

   typedef uint16_t _reboot_type;
  _reboot_type reboot;

   typedef uint16_t _dfmode_type;
  _dfmode_type dfmode;

   typedef uint16_t _master_slaven_type;
  _master_slaven_type master_slaven;

   typedef uint16_t _logena_type;
  _logena_type logena;

   typedef uint16_t _acsten_type;
  _acsten_type acsten;

   typedef uint16_t _acstmast_slaven_type;
  _acstmast_slaven_type acstmast_slaven;

   typedef uint16_t _acstmfg_type;
  _acstmfg_type acstmfg;

   typedef uint16_t _lamdid_type;
  _lamdid_type lamdid;

   typedef uint16_t _ramdid_type;
  _ramdid_type ramdid;

   typedef uint16_t _sensitivity_ctrl_type;
  _sensitivity_ctrl_type sensitivity_ctrl;

   typedef uint16_t _lrhaln_type;
  _lrhaln_type lrhaln;

   typedef uint16_t _status1hz_enable_type;
  _status1hz_enable_type status1hz_enable;





  typedef boost::shared_ptr< ::ds_ocomms_msgs::ModemSettings_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::ds_ocomms_msgs::ModemSettings_<ContainerAllocator> const> ConstPtr;

}; // struct ModemSettings_

typedef ::ds_ocomms_msgs::ModemSettings_<std::allocator<void> > ModemSettings;

typedef boost::shared_ptr< ::ds_ocomms_msgs::ModemSettings > ModemSettingsPtr;
typedef boost::shared_ptr< ::ds_ocomms_msgs::ModemSettings const> ModemSettingsConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::ds_ocomms_msgs::ModemSettings_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::ds_ocomms_msgs::ModemSettings_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::ds_ocomms_msgs::ModemSettings_<ContainerAllocator1> & lhs, const ::ds_ocomms_msgs::ModemSettings_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.ds_header == rhs.ds_header &&
    lhs.ip_addr == rhs.ip_addr &&
    lhs.netmask == rhs.netmask &&
    lhs.brdcst == rhs.brdcst &&
    lhs.dfltgw == rhs.dfltgw &&
    lhs.dfltip == rhs.dfltip &&
    lhs.dflmac == rhs.dflmac &&
    lhs.dflprt == rhs.dflprt &&
    lhs.laripa == rhs.laripa &&
    lhs.larmac == rhs.larmac &&
    lhs.larprt == rhs.larprt &&
    lhs.lfpipa == rhs.lfpipa &&
    lhs.lfpmac == rhs.lfpmac &&
    lhs.lfpprt == rhs.lfpprt &&
    lhs.remipa == rhs.remipa &&
    lhs.raripa == rhs.raripa &&
    lhs.rarmac == rhs.rarmac &&
    lhs.rsubnt == rhs.rsubnt &&
    lhs.brdgen == rhs.brdgen &&
    lhs.brdgip == rhs.brdgip &&
    lhs.guiipa == rhs.guiipa &&
    lhs.fpg3vr == rhs.fpg3vr &&
    lhs.fpg6vr == rhs.fpg6vr &&
    lhs.softvr == rhs.softvr &&
    lhs.reboot == rhs.reboot &&
    lhs.dfmode == rhs.dfmode &&
    lhs.master_slaven == rhs.master_slaven &&
    lhs.logena == rhs.logena &&
    lhs.acsten == rhs.acsten &&
    lhs.acstmast_slaven == rhs.acstmast_slaven &&
    lhs.acstmfg == rhs.acstmfg &&
    lhs.lamdid == rhs.lamdid &&
    lhs.ramdid == rhs.ramdid &&
    lhs.sensitivity_ctrl == rhs.sensitivity_ctrl &&
    lhs.lrhaln == rhs.lrhaln &&
    lhs.status1hz_enable == rhs.status1hz_enable;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::ds_ocomms_msgs::ModemSettings_<ContainerAllocator1> & lhs, const ::ds_ocomms_msgs::ModemSettings_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace ds_ocomms_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::ds_ocomms_msgs::ModemSettings_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::ds_ocomms_msgs::ModemSettings_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::ds_ocomms_msgs::ModemSettings_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::ds_ocomms_msgs::ModemSettings_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::ds_ocomms_msgs::ModemSettings_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::ds_ocomms_msgs::ModemSettings_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::ds_ocomms_msgs::ModemSettings_<ContainerAllocator> >
{
  static const char* value()
  {
    return "2970c57aa0f7c200f8f354f9e2ac5e37";
  }

  static const char* value(const ::ds_ocomms_msgs::ModemSettings_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x2970c57aa0f7c200ULL;
  static const uint64_t static_value2 = 0xf8f354f9e2ac5e37ULL;
};

template<class ContainerAllocator>
struct DataType< ::ds_ocomms_msgs::ModemSettings_<ContainerAllocator> >
{
  static const char* value()
  {
    return "ds_ocomms_msgs/ModemSettings";
  }

  static const char* value(const ::ds_ocomms_msgs::ModemSettings_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::ds_ocomms_msgs::ModemSettings_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# The standard 2-part DsHeader block\n"
"# This allows both a standard ROS header and DS-specific header blocks\n"
"# See HEADERS.md in ds_core_msgs for details\n"
"std_msgs/Header header\n"
"ds_core_msgs/DsHeader ds_header\n"
"\n"
"string ip_addr\n"
"string netmask\n"
"string brdcst\n"
"string dfltgw\n"
"string dfltip\n"
"string dflmac\n"
"float64 dflprt\n"
"string laripa\n"
"string larmac\n"
"float64 larprt\n"
"string lfpipa\n"
"string lfpmac\n"
"float64 lfpprt \n"
"string remipa\n"
"string raripa\n"
"string rarmac\n"
"string rsubnt\n"
"uint16 brdgen\n"
"string brdgip\n"
"string guiipa \n"
"string fpg3vr\n"
"string fpg6vr\n"
"string softvr\n"
"uint16 reboot\n"
"uint16 dfmode\n"
"uint16 master_slaven\n"
"uint16 logena\n"
"uint16 acsten\n"
"uint16 acstmast_slaven\n"
"uint16 acstmfg\n"
"uint16 lamdid\n"
"uint16 ramdid\n"
"uint16 sensitivity_ctrl\n"
"uint16 lrhaln\n"
"uint16 status1hz_enable\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
"\n"
"================================================================================\n"
"MSG: ds_core_msgs/DsHeader\n"
"# This is half our standard header for ds_msgs; see\n"
"# HEADERS.md for details\n"
"\n"
"# This header should ALWAYS be paired with a std_msgs/Header\n"
"# and should ALWAYS reference HEADERS.md.  If you're looking at this\n"
"# file to add headers to a type, you probably want to copy/paste\n"
"# the following block:\n"
"#\n"
"#     # The standard 2-part DsHeader block\n"
"#     # This allows both a standard ROS header and DS-specific header blocks\n"
"#     # See HEADERS.md in ds_core_msgs for details\n"
"#     std_msgs/Header header\n"
"#     ds_core_msgs/DsHeader ds_header\n"
"#\n"
"\n"
"# Time data was received or sent out (i/o time)\n"
"time io_time\n"
"\n"
"# Sensor source UUID\n"
"uint8[16] source_uuid\n"
"\n"
;
  }

  static const char* value(const ::ds_ocomms_msgs::ModemSettings_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::ds_ocomms_msgs::ModemSettings_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.ds_header);
      stream.next(m.ip_addr);
      stream.next(m.netmask);
      stream.next(m.brdcst);
      stream.next(m.dfltgw);
      stream.next(m.dfltip);
      stream.next(m.dflmac);
      stream.next(m.dflprt);
      stream.next(m.laripa);
      stream.next(m.larmac);
      stream.next(m.larprt);
      stream.next(m.lfpipa);
      stream.next(m.lfpmac);
      stream.next(m.lfpprt);
      stream.next(m.remipa);
      stream.next(m.raripa);
      stream.next(m.rarmac);
      stream.next(m.rsubnt);
      stream.next(m.brdgen);
      stream.next(m.brdgip);
      stream.next(m.guiipa);
      stream.next(m.fpg3vr);
      stream.next(m.fpg6vr);
      stream.next(m.softvr);
      stream.next(m.reboot);
      stream.next(m.dfmode);
      stream.next(m.master_slaven);
      stream.next(m.logena);
      stream.next(m.acsten);
      stream.next(m.acstmast_slaven);
      stream.next(m.acstmfg);
      stream.next(m.lamdid);
      stream.next(m.ramdid);
      stream.next(m.sensitivity_ctrl);
      stream.next(m.lrhaln);
      stream.next(m.status1hz_enable);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct ModemSettings_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::ds_ocomms_msgs::ModemSettings_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::ds_ocomms_msgs::ModemSettings_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "ds_header: ";
    s << std::endl;
    Printer< ::ds_core_msgs::DsHeader_<ContainerAllocator> >::stream(s, indent + "  ", v.ds_header);
    s << indent << "ip_addr: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.ip_addr);
    s << indent << "netmask: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.netmask);
    s << indent << "brdcst: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.brdcst);
    s << indent << "dfltgw: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.dfltgw);
    s << indent << "dfltip: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.dfltip);
    s << indent << "dflmac: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.dflmac);
    s << indent << "dflprt: ";
    Printer<double>::stream(s, indent + "  ", v.dflprt);
    s << indent << "laripa: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.laripa);
    s << indent << "larmac: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.larmac);
    s << indent << "larprt: ";
    Printer<double>::stream(s, indent + "  ", v.larprt);
    s << indent << "lfpipa: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.lfpipa);
    s << indent << "lfpmac: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.lfpmac);
    s << indent << "lfpprt: ";
    Printer<double>::stream(s, indent + "  ", v.lfpprt);
    s << indent << "remipa: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.remipa);
    s << indent << "raripa: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.raripa);
    s << indent << "rarmac: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.rarmac);
    s << indent << "rsubnt: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.rsubnt);
    s << indent << "brdgen: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.brdgen);
    s << indent << "brdgip: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.brdgip);
    s << indent << "guiipa: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.guiipa);
    s << indent << "fpg3vr: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.fpg3vr);
    s << indent << "fpg6vr: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.fpg6vr);
    s << indent << "softvr: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.softvr);
    s << indent << "reboot: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.reboot);
    s << indent << "dfmode: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.dfmode);
    s << indent << "master_slaven: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.master_slaven);
    s << indent << "logena: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.logena);
    s << indent << "acsten: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.acsten);
    s << indent << "acstmast_slaven: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.acstmast_slaven);
    s << indent << "acstmfg: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.acstmfg);
    s << indent << "lamdid: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.lamdid);
    s << indent << "ramdid: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.ramdid);
    s << indent << "sensitivity_ctrl: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.sensitivity_ctrl);
    s << indent << "lrhaln: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.lrhaln);
    s << indent << "status1hz_enable: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.status1hz_enable);
  }
};

} // namespace message_operations
} // namespace ros

#endif // DS_OCOMMS_MSGS_MESSAGE_MODEMSETTINGS_H
