// Generated by gencpp from file ds_sensor_msgs/NortekDF21.msg
// DO NOT EDIT!


#ifndef DS_SENSOR_MSGS_MESSAGE_NORTEKDF21_H
#define DS_SENSOR_MSGS_MESSAGE_NORTEKDF21_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>
#include <ds_core_msgs/DsHeader.h>

namespace ds_sensor_msgs
{
template <class ContainerAllocator>
struct NortekDF21_
{
  typedef NortekDF21_<ContainerAllocator> Type;

  NortekDF21_()
    : header()
    , ds_header()
    , dvl_type(0)
    , altitude_sum(0.0)
    , speed_gnd(0.0)
    , course_gnd(0.0)
    , good_beams(0)
    , dvl_time(0.0)
    , version(0)
    , offsetOfData(0)
    , serialNumber(0)
    , year(0)
    , month(0)
    , day(0)
    , hour(0)
    , minute(0)
    , seconds(0)
    , microSeconds(0)
    , nBeams(0)
    , error(0)
    , status(0)
    , speed_sound(0.0)
    , temperature(0.0)
    , pressure(0.0)
    , velBeam()
    , distBeam()
    , fomBeam()
    , timeDiff1Beam()
    , timeDiff2Beam()
    , timeVelEstBeam()
    , velX(0.0)
    , velY(0.0)
    , velZ1(0.0)
    , velZ2(0.0)
    , fomX(0.0)
    , fomY(0.0)
    , fomZ1(0.0)
    , fomZ2(0.0)
    , timeDiff1X(0.0)
    , timeDiff1Y(0.0)
    , timeDiff1Z1(0.0)
    , timeDiff1Z2(0.0)
    , timeDiff2X(0.0)
    , timeDiff2Y(0.0)
    , timeDiff2Z1(0.0)
    , timeDiff2Z2(0.0)
    , timeVelEstX(0.0)
    , timeVelEstY(0.0)
    , timeVelEstZ1(0.0)
    , timeVelEstZ2(0.0)  {
      velBeam.assign(0.0);

      distBeam.assign(0.0);

      fomBeam.assign(0.0);

      timeDiff1Beam.assign(0.0);

      timeDiff2Beam.assign(0.0);

      timeVelEstBeam.assign(0.0);
  }
  NortekDF21_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , ds_header(_alloc)
    , dvl_type(0)
    , altitude_sum(0.0)
    , speed_gnd(0.0)
    , course_gnd(0.0)
    , good_beams(0)
    , dvl_time(0.0)
    , version(0)
    , offsetOfData(0)
    , serialNumber(0)
    , year(0)
    , month(0)
    , day(0)
    , hour(0)
    , minute(0)
    , seconds(0)
    , microSeconds(0)
    , nBeams(0)
    , error(0)
    , status(0)
    , speed_sound(0.0)
    , temperature(0.0)
    , pressure(0.0)
    , velBeam()
    , distBeam()
    , fomBeam()
    , timeDiff1Beam()
    , timeDiff2Beam()
    , timeVelEstBeam()
    , velX(0.0)
    , velY(0.0)
    , velZ1(0.0)
    , velZ2(0.0)
    , fomX(0.0)
    , fomY(0.0)
    , fomZ1(0.0)
    , fomZ2(0.0)
    , timeDiff1X(0.0)
    , timeDiff1Y(0.0)
    , timeDiff1Z1(0.0)
    , timeDiff1Z2(0.0)
    , timeDiff2X(0.0)
    , timeDiff2Y(0.0)
    , timeDiff2Z1(0.0)
    , timeDiff2Z2(0.0)
    , timeVelEstX(0.0)
    , timeVelEstY(0.0)
    , timeVelEstZ1(0.0)
    , timeVelEstZ2(0.0)  {
  (void)_alloc;
      velBeam.assign(0.0);

      distBeam.assign(0.0);

      fomBeam.assign(0.0);

      timeDiff1Beam.assign(0.0);

      timeDiff2Beam.assign(0.0);

      timeVelEstBeam.assign(0.0);
  }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef  ::ds_core_msgs::DsHeader_<ContainerAllocator>  _ds_header_type;
  _ds_header_type ds_header;

   typedef uint8_t _dvl_type_type;
  _dvl_type_type dvl_type;

   typedef double _altitude_sum_type;
  _altitude_sum_type altitude_sum;

   typedef double _speed_gnd_type;
  _speed_gnd_type speed_gnd;

   typedef double _course_gnd_type;
  _course_gnd_type course_gnd;

   typedef uint8_t _good_beams_type;
  _good_beams_type good_beams;

   typedef double _dvl_time_type;
  _dvl_time_type dvl_time;

   typedef uint8_t _version_type;
  _version_type version;

   typedef uint8_t _offsetOfData_type;
  _offsetOfData_type offsetOfData;

   typedef uint32_t _serialNumber_type;
  _serialNumber_type serialNumber;

   typedef uint8_t _year_type;
  _year_type year;

   typedef uint8_t _month_type;
  _month_type month;

   typedef uint8_t _day_type;
  _day_type day;

   typedef uint8_t _hour_type;
  _hour_type hour;

   typedef uint8_t _minute_type;
  _minute_type minute;

   typedef uint8_t _seconds_type;
  _seconds_type seconds;

   typedef uint16_t _microSeconds_type;
  _microSeconds_type microSeconds;

   typedef uint16_t _nBeams_type;
  _nBeams_type nBeams;

   typedef uint32_t _error_type;
  _error_type error;

   typedef uint32_t _status_type;
  _status_type status;

   typedef float _speed_sound_type;
  _speed_sound_type speed_sound;

   typedef float _temperature_type;
  _temperature_type temperature;

   typedef float _pressure_type;
  _pressure_type pressure;

   typedef boost::array<float, 4>  _velBeam_type;
  _velBeam_type velBeam;

   typedef boost::array<float, 4>  _distBeam_type;
  _distBeam_type distBeam;

   typedef boost::array<float, 4>  _fomBeam_type;
  _fomBeam_type fomBeam;

   typedef boost::array<float, 4>  _timeDiff1Beam_type;
  _timeDiff1Beam_type timeDiff1Beam;

   typedef boost::array<float, 4>  _timeDiff2Beam_type;
  _timeDiff2Beam_type timeDiff2Beam;

   typedef boost::array<float, 4>  _timeVelEstBeam_type;
  _timeVelEstBeam_type timeVelEstBeam;

   typedef float _velX_type;
  _velX_type velX;

   typedef float _velY_type;
  _velY_type velY;

   typedef float _velZ1_type;
  _velZ1_type velZ1;

   typedef float _velZ2_type;
  _velZ2_type velZ2;

   typedef float _fomX_type;
  _fomX_type fomX;

   typedef float _fomY_type;
  _fomY_type fomY;

   typedef float _fomZ1_type;
  _fomZ1_type fomZ1;

   typedef float _fomZ2_type;
  _fomZ2_type fomZ2;

   typedef float _timeDiff1X_type;
  _timeDiff1X_type timeDiff1X;

   typedef float _timeDiff1Y_type;
  _timeDiff1Y_type timeDiff1Y;

   typedef float _timeDiff1Z1_type;
  _timeDiff1Z1_type timeDiff1Z1;

   typedef float _timeDiff1Z2_type;
  _timeDiff1Z2_type timeDiff1Z2;

   typedef float _timeDiff2X_type;
  _timeDiff2X_type timeDiff2X;

   typedef float _timeDiff2Y_type;
  _timeDiff2Y_type timeDiff2Y;

   typedef float _timeDiff2Z1_type;
  _timeDiff2Z1_type timeDiff2Z1;

   typedef float _timeDiff2Z2_type;
  _timeDiff2Z2_type timeDiff2Z2;

   typedef float _timeVelEstX_type;
  _timeVelEstX_type timeVelEstX;

   typedef float _timeVelEstY_type;
  _timeVelEstY_type timeVelEstY;

   typedef float _timeVelEstZ1_type;
  _timeVelEstZ1_type timeVelEstZ1;

   typedef float _timeVelEstZ2_type;
  _timeVelEstZ2_type timeVelEstZ2;



// reducing the odds to have name collisions with Windows.h 
#if defined(_WIN32) && defined(DVL_TYPE_PISTON)
  #undef DVL_TYPE_PISTON
#endif
#if defined(_WIN32) && defined(DVL_TYPE_PHASED_ARRAY)
  #undef DVL_TYPE_PHASED_ARRAY
#endif

  enum {
    DVL_TYPE_PISTON = 0u,
    DVL_TYPE_PHASED_ARRAY = 1u,
  };


  typedef boost::shared_ptr< ::ds_sensor_msgs::NortekDF21_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::ds_sensor_msgs::NortekDF21_<ContainerAllocator> const> ConstPtr;

}; // struct NortekDF21_

typedef ::ds_sensor_msgs::NortekDF21_<std::allocator<void> > NortekDF21;

typedef boost::shared_ptr< ::ds_sensor_msgs::NortekDF21 > NortekDF21Ptr;
typedef boost::shared_ptr< ::ds_sensor_msgs::NortekDF21 const> NortekDF21ConstPtr;

// constants requiring out of line definition

   

   



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::ds_sensor_msgs::NortekDF21_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::ds_sensor_msgs::NortekDF21_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::ds_sensor_msgs::NortekDF21_<ContainerAllocator1> & lhs, const ::ds_sensor_msgs::NortekDF21_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.ds_header == rhs.ds_header &&
    lhs.dvl_type == rhs.dvl_type &&
    lhs.altitude_sum == rhs.altitude_sum &&
    lhs.speed_gnd == rhs.speed_gnd &&
    lhs.course_gnd == rhs.course_gnd &&
    lhs.good_beams == rhs.good_beams &&
    lhs.dvl_time == rhs.dvl_time &&
    lhs.version == rhs.version &&
    lhs.offsetOfData == rhs.offsetOfData &&
    lhs.serialNumber == rhs.serialNumber &&
    lhs.year == rhs.year &&
    lhs.month == rhs.month &&
    lhs.day == rhs.day &&
    lhs.hour == rhs.hour &&
    lhs.minute == rhs.minute &&
    lhs.seconds == rhs.seconds &&
    lhs.microSeconds == rhs.microSeconds &&
    lhs.nBeams == rhs.nBeams &&
    lhs.error == rhs.error &&
    lhs.status == rhs.status &&
    lhs.speed_sound == rhs.speed_sound &&
    lhs.temperature == rhs.temperature &&
    lhs.pressure == rhs.pressure &&
    lhs.velBeam == rhs.velBeam &&
    lhs.distBeam == rhs.distBeam &&
    lhs.fomBeam == rhs.fomBeam &&
    lhs.timeDiff1Beam == rhs.timeDiff1Beam &&
    lhs.timeDiff2Beam == rhs.timeDiff2Beam &&
    lhs.timeVelEstBeam == rhs.timeVelEstBeam &&
    lhs.velX == rhs.velX &&
    lhs.velY == rhs.velY &&
    lhs.velZ1 == rhs.velZ1 &&
    lhs.velZ2 == rhs.velZ2 &&
    lhs.fomX == rhs.fomX &&
    lhs.fomY == rhs.fomY &&
    lhs.fomZ1 == rhs.fomZ1 &&
    lhs.fomZ2 == rhs.fomZ2 &&
    lhs.timeDiff1X == rhs.timeDiff1X &&
    lhs.timeDiff1Y == rhs.timeDiff1Y &&
    lhs.timeDiff1Z1 == rhs.timeDiff1Z1 &&
    lhs.timeDiff1Z2 == rhs.timeDiff1Z2 &&
    lhs.timeDiff2X == rhs.timeDiff2X &&
    lhs.timeDiff2Y == rhs.timeDiff2Y &&
    lhs.timeDiff2Z1 == rhs.timeDiff2Z1 &&
    lhs.timeDiff2Z2 == rhs.timeDiff2Z2 &&
    lhs.timeVelEstX == rhs.timeVelEstX &&
    lhs.timeVelEstY == rhs.timeVelEstY &&
    lhs.timeVelEstZ1 == rhs.timeVelEstZ1 &&
    lhs.timeVelEstZ2 == rhs.timeVelEstZ2;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::ds_sensor_msgs::NortekDF21_<ContainerAllocator1> & lhs, const ::ds_sensor_msgs::NortekDF21_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace ds_sensor_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::ds_sensor_msgs::NortekDF21_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::ds_sensor_msgs::NortekDF21_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::ds_sensor_msgs::NortekDF21_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::ds_sensor_msgs::NortekDF21_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::ds_sensor_msgs::NortekDF21_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::ds_sensor_msgs::NortekDF21_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::ds_sensor_msgs::NortekDF21_<ContainerAllocator> >
{
  static const char* value()
  {
    return "c0eb1b2fba2301446195ec5c1c67adb4";
  }

  static const char* value(const ::ds_sensor_msgs::NortekDF21_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xc0eb1b2fba230144ULL;
  static const uint64_t static_value2 = 0x6195ec5c1c67adb4ULL;
};

template<class ContainerAllocator>
struct DataType< ::ds_sensor_msgs::NortekDF21_<ContainerAllocator> >
{
  static const char* value()
  {
    return "ds_sensor_msgs/NortekDF21";
  }

  static const char* value(const ::ds_sensor_msgs::NortekDF21_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::ds_sensor_msgs::NortekDF21_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# The standard 2-part DsHeader block\n"
"# This allows both a standard ROS header and DS-specific header blocks\n"
"# See HEADERS.md in ds_core_msgs for details\n"
"std_msgs/Header header\n"
"ds_core_msgs/DsHeader ds_header\n"
"\n"
"################################\n"
"# Standard DVL type disclaimer #\n"
"################################\n"
"\n"
"# Standard array with one piston transducer for each beam\n"
"# If you have 4-5 individual disks on your DVL, use this one.\n"
"# Examples include Sonardyne Syrinx, Nortek DVLs, and RDI Workhorse\n"
"uint8 DVL_TYPE_PISTON=0\n"
"\n"
"# Newfangled phased-array DVL.  If you have one giant disk with complicated stuff on it,\n"
"# probably this one.\n"
"# Examples include newer RDI DVLs such as pathfinder, pioneer, and tasman.\n"
"uint8 DVL_TYPE_PHASED_ARRAY=1\n"
"\n"
"# Type of DVL array employed (see above).  Necessary when\n"
"# deciding how to apply sound velocity corrections\n"
"uint8 dvl_type\n"
"\n"
"#################\n"
"# DVL processed #\n"
"#################\n"
"\n"
"float64 altitude_sum\n"
"float64 speed_gnd\n"
"float64 course_gnd\n"
"uint8 good_beams\n"
"float64 dvl_time\n"
"\n"
"################\n"
"# DF21/22 Mode #\n"
"################\n"
"\n"
"#  All distances are in m, velocities in m/s, intensities in dB\n"
"\n"
"uint8 version\n"
"uint8 offsetOfData\n"
"uint32 serialNumber\n"
"uint8 year\n"
"uint8 month\n"
"uint8 day\n"
"uint8 hour\n"
"uint8 minute\n"
"uint8 seconds\n"
"uint16 microSeconds\n"
"uint16 nBeams\n"
"uint32 error\n"
"uint32 status\n"
"float32 speed_sound\n"
"float32 temperature\n"
"float32 pressure\n"
"\n"
"#############\n"
"# Beam Data #\n"
"#############\n"
"\n"
"float32[4] velBeam    #Velocities for each beam\n"
"float32[4] distBeam   #Distances for each beam\n"
"float32[4] fomBeam    #Figure of merit for each beam\n"
"float32[4] timeDiff1Beam  #DT1 for each beam\n"
"float32[4] timeDiff2Beam  #DT2 for each beam\n"
"float32[4] timeVelEstBeam #Duration of velocity estimate for each beam\n"
"\n"
"#############\n"
"# XYZ Data #\n"
"#############\n"
"float32 velX  #Velocity X\n"
"float32 velY  #Velocity Y\n"
"float32 velZ1 #Velocity Z1\n"
"float32 velZ2 #Velocity Z2\n"
"float32 fomX  #Figure of Merit X\n"
"float32 fomY  #Figure of Merit Y\n"
"float32 fomZ1 #Figure of Merit Z1\n"
"float32 fomZ2 #Figure of Merit Z2\n"
"float32 timeDiff1X    #Time from trigger to center of bottom echo\n"
"float32 timeDiff1Y    #Same as above\n"
"float32 timeDiff1Z1   #Same as above\n"
"float32 timeDiff1Z2   #Same as above\n"
"float32 timeDiff2X    #Time from start of NMEA output msg to center of bottom echo\n"
"float32 timeDiff2Y    #Same as above\n"
"float32 timeDiff2Z1   #Same as above\n"
"float32 timeDiff2Z2   #Same as above\n"
"float32 timeVelEstX   #Duration of velocity estimate for each component\n"
"float32 timeVelEstY   #Same as above\n"
"float32 timeVelEstZ1  #Same as above\n"
"float32 timeVelEstZ2  #Same as above\n"
"\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
"\n"
"================================================================================\n"
"MSG: ds_core_msgs/DsHeader\n"
"# This is half our standard header for ds_msgs; see\n"
"# HEADERS.md for details\n"
"\n"
"# This header should ALWAYS be paired with a std_msgs/Header\n"
"# and should ALWAYS reference HEADERS.md.  If you're looking at this\n"
"# file to add headers to a type, you probably want to copy/paste\n"
"# the following block:\n"
"#\n"
"#     # The standard 2-part DsHeader block\n"
"#     # This allows both a standard ROS header and DS-specific header blocks\n"
"#     # See HEADERS.md in ds_core_msgs for details\n"
"#     std_msgs/Header header\n"
"#     ds_core_msgs/DsHeader ds_header\n"
"#\n"
"\n"
"# Time data was received or sent out (i/o time)\n"
"time io_time\n"
"\n"
"# Sensor source UUID\n"
"uint8[16] source_uuid\n"
"\n"
;
  }

  static const char* value(const ::ds_sensor_msgs::NortekDF21_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::ds_sensor_msgs::NortekDF21_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.ds_header);
      stream.next(m.dvl_type);
      stream.next(m.altitude_sum);
      stream.next(m.speed_gnd);
      stream.next(m.course_gnd);
      stream.next(m.good_beams);
      stream.next(m.dvl_time);
      stream.next(m.version);
      stream.next(m.offsetOfData);
      stream.next(m.serialNumber);
      stream.next(m.year);
      stream.next(m.month);
      stream.next(m.day);
      stream.next(m.hour);
      stream.next(m.minute);
      stream.next(m.seconds);
      stream.next(m.microSeconds);
      stream.next(m.nBeams);
      stream.next(m.error);
      stream.next(m.status);
      stream.next(m.speed_sound);
      stream.next(m.temperature);
      stream.next(m.pressure);
      stream.next(m.velBeam);
      stream.next(m.distBeam);
      stream.next(m.fomBeam);
      stream.next(m.timeDiff1Beam);
      stream.next(m.timeDiff2Beam);
      stream.next(m.timeVelEstBeam);
      stream.next(m.velX);
      stream.next(m.velY);
      stream.next(m.velZ1);
      stream.next(m.velZ2);
      stream.next(m.fomX);
      stream.next(m.fomY);
      stream.next(m.fomZ1);
      stream.next(m.fomZ2);
      stream.next(m.timeDiff1X);
      stream.next(m.timeDiff1Y);
      stream.next(m.timeDiff1Z1);
      stream.next(m.timeDiff1Z2);
      stream.next(m.timeDiff2X);
      stream.next(m.timeDiff2Y);
      stream.next(m.timeDiff2Z1);
      stream.next(m.timeDiff2Z2);
      stream.next(m.timeVelEstX);
      stream.next(m.timeVelEstY);
      stream.next(m.timeVelEstZ1);
      stream.next(m.timeVelEstZ2);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct NortekDF21_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::ds_sensor_msgs::NortekDF21_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::ds_sensor_msgs::NortekDF21_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "ds_header: ";
    s << std::endl;
    Printer< ::ds_core_msgs::DsHeader_<ContainerAllocator> >::stream(s, indent + "  ", v.ds_header);
    s << indent << "dvl_type: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.dvl_type);
    s << indent << "altitude_sum: ";
    Printer<double>::stream(s, indent + "  ", v.altitude_sum);
    s << indent << "speed_gnd: ";
    Printer<double>::stream(s, indent + "  ", v.speed_gnd);
    s << indent << "course_gnd: ";
    Printer<double>::stream(s, indent + "  ", v.course_gnd);
    s << indent << "good_beams: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.good_beams);
    s << indent << "dvl_time: ";
    Printer<double>::stream(s, indent + "  ", v.dvl_time);
    s << indent << "version: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.version);
    s << indent << "offsetOfData: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.offsetOfData);
    s << indent << "serialNumber: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.serialNumber);
    s << indent << "year: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.year);
    s << indent << "month: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.month);
    s << indent << "day: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.day);
    s << indent << "hour: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.hour);
    s << indent << "minute: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.minute);
    s << indent << "seconds: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.seconds);
    s << indent << "microSeconds: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.microSeconds);
    s << indent << "nBeams: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.nBeams);
    s << indent << "error: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.error);
    s << indent << "status: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.status);
    s << indent << "speed_sound: ";
    Printer<float>::stream(s, indent + "  ", v.speed_sound);
    s << indent << "temperature: ";
    Printer<float>::stream(s, indent + "  ", v.temperature);
    s << indent << "pressure: ";
    Printer<float>::stream(s, indent + "  ", v.pressure);
    s << indent << "velBeam[]" << std::endl;
    for (size_t i = 0; i < v.velBeam.size(); ++i)
    {
      s << indent << "  velBeam[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.velBeam[i]);
    }
    s << indent << "distBeam[]" << std::endl;
    for (size_t i = 0; i < v.distBeam.size(); ++i)
    {
      s << indent << "  distBeam[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.distBeam[i]);
    }
    s << indent << "fomBeam[]" << std::endl;
    for (size_t i = 0; i < v.fomBeam.size(); ++i)
    {
      s << indent << "  fomBeam[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.fomBeam[i]);
    }
    s << indent << "timeDiff1Beam[]" << std::endl;
    for (size_t i = 0; i < v.timeDiff1Beam.size(); ++i)
    {
      s << indent << "  timeDiff1Beam[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.timeDiff1Beam[i]);
    }
    s << indent << "timeDiff2Beam[]" << std::endl;
    for (size_t i = 0; i < v.timeDiff2Beam.size(); ++i)
    {
      s << indent << "  timeDiff2Beam[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.timeDiff2Beam[i]);
    }
    s << indent << "timeVelEstBeam[]" << std::endl;
    for (size_t i = 0; i < v.timeVelEstBeam.size(); ++i)
    {
      s << indent << "  timeVelEstBeam[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.timeVelEstBeam[i]);
    }
    s << indent << "velX: ";
    Printer<float>::stream(s, indent + "  ", v.velX);
    s << indent << "velY: ";
    Printer<float>::stream(s, indent + "  ", v.velY);
    s << indent << "velZ1: ";
    Printer<float>::stream(s, indent + "  ", v.velZ1);
    s << indent << "velZ2: ";
    Printer<float>::stream(s, indent + "  ", v.velZ2);
    s << indent << "fomX: ";
    Printer<float>::stream(s, indent + "  ", v.fomX);
    s << indent << "fomY: ";
    Printer<float>::stream(s, indent + "  ", v.fomY);
    s << indent << "fomZ1: ";
    Printer<float>::stream(s, indent + "  ", v.fomZ1);
    s << indent << "fomZ2: ";
    Printer<float>::stream(s, indent + "  ", v.fomZ2);
    s << indent << "timeDiff1X: ";
    Printer<float>::stream(s, indent + "  ", v.timeDiff1X);
    s << indent << "timeDiff1Y: ";
    Printer<float>::stream(s, indent + "  ", v.timeDiff1Y);
    s << indent << "timeDiff1Z1: ";
    Printer<float>::stream(s, indent + "  ", v.timeDiff1Z1);
    s << indent << "timeDiff1Z2: ";
    Printer<float>::stream(s, indent + "  ", v.timeDiff1Z2);
    s << indent << "timeDiff2X: ";
    Printer<float>::stream(s, indent + "  ", v.timeDiff2X);
    s << indent << "timeDiff2Y: ";
    Printer<float>::stream(s, indent + "  ", v.timeDiff2Y);
    s << indent << "timeDiff2Z1: ";
    Printer<float>::stream(s, indent + "  ", v.timeDiff2Z1);
    s << indent << "timeDiff2Z2: ";
    Printer<float>::stream(s, indent + "  ", v.timeDiff2Z2);
    s << indent << "timeVelEstX: ";
    Printer<float>::stream(s, indent + "  ", v.timeVelEstX);
    s << indent << "timeVelEstY: ";
    Printer<float>::stream(s, indent + "  ", v.timeVelEstY);
    s << indent << "timeVelEstZ1: ";
    Printer<float>::stream(s, indent + "  ", v.timeVelEstZ1);
    s << indent << "timeVelEstZ2: ";
    Printer<float>::stream(s, indent + "  ", v.timeVelEstZ2);
  }
};

} // namespace message_operations
} // namespace ros

#endif // DS_SENSOR_MSGS_MESSAGE_NORTEKDF21_H
