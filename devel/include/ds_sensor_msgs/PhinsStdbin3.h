// Generated by gencpp from file ds_sensor_msgs/PhinsStdbin3.msg
// DO NOT EDIT!


#ifndef DS_SENSOR_MSGS_MESSAGE_PHINSSTDBIN3_H
#define DS_SENSOR_MSGS_MESSAGE_PHINSSTDBIN3_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>
#include <ds_core_msgs/DsHeader.h>

namespace ds_sensor_msgs
{
template <class ContainerAllocator>
struct PhinsStdbin3_
{
  typedef PhinsStdbin3_<ContainerAllocator> Type;

  PhinsStdbin3_()
    : header()
    , ds_header()
    , nav_fields(0)
    , extended_nav_fields(0)
    , external_data_fields(0)
    , nav_validity_time(0.0)
    , counter(0)
    , heading(0.0)
    , roll(0.0)
    , pitch(0.0)
    , heading_stddev(0.0)
    , roll_stddev(0.0)
    , pitch_stddev(0.0)
    , rt_heave_XVnH()
    , smart_heave_validity_time(0.0)
    , smart_heave(0.0)
    , heading_rate(0.0)
    , roll_rate(0.0)
    , pitch_rate(0.0)
    , body_rates_XVn()
    , body_accel_XVn()
    , latitude(0.0)
    , longitude(0.0)
    , altitude(0.0)
    , altitude_reference(0)
    , position_cov()
    , altitude_stddev(0.0)
    , velocity_NEU()
    , velocity_stddev_NEU()
    , current_NE()
    , current_stddev_NE()
    , day(0)
    , month(0)
    , year(0)
    , sensor_status()
    , ins_algo_status()
    , ins_system_status()
    , ins_user_status(0)
    , ahrs_algo_status(0)
    , ahrs_system_status()
    , ahrs_user_status(0)
    , heaveSurgeSway_speed_XVnH()
    , body_velocity_XVn()
    , geo_accel_NEU()
    , course_over_ground(0.0)
    , speed_over_ground(0.0)
    , temp_avg_fog(0.0)
    , temp_avg_acc(0.0)
    , temp_board(0.0)
    , attitude_quaternion()
    , attitude_quaternion_stddev()
    , raw_accel_XVn()
    , body_accel_stddev_XVn()
    , body_rotrate_stddev_XVn()
    , raw_rot_acc_XVn()
    , raw_rot_acc_stddev_XVn()
    , raw_rot_rate_XVn()  {
      rt_heave_XVnH.assign(0.0);

      body_rates_XVn.assign(0.0);

      body_accel_XVn.assign(0.0);

      position_cov.assign(0.0);

      velocity_NEU.assign(0.0);

      velocity_stddev_NEU.assign(0.0);

      current_NE.assign(0.0);

      current_stddev_NE.assign(0.0);

      sensor_status.assign(0);

      ins_algo_status.assign(0);

      ins_system_status.assign(0);

      ahrs_system_status.assign(0);

      heaveSurgeSway_speed_XVnH.assign(0.0);

      body_velocity_XVn.assign(0.0);

      geo_accel_NEU.assign(0.0);

      attitude_quaternion.assign(0.0);

      attitude_quaternion_stddev.assign(0.0);

      raw_accel_XVn.assign(0.0);

      body_accel_stddev_XVn.assign(0.0);

      body_rotrate_stddev_XVn.assign(0.0);

      raw_rot_acc_XVn.assign(0.0);

      raw_rot_acc_stddev_XVn.assign(0.0);

      raw_rot_rate_XVn.assign(0.0);
  }
  PhinsStdbin3_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , ds_header(_alloc)
    , nav_fields(0)
    , extended_nav_fields(0)
    , external_data_fields(0)
    , nav_validity_time(0.0)
    , counter(0)
    , heading(0.0)
    , roll(0.0)
    , pitch(0.0)
    , heading_stddev(0.0)
    , roll_stddev(0.0)
    , pitch_stddev(0.0)
    , rt_heave_XVnH()
    , smart_heave_validity_time(0.0)
    , smart_heave(0.0)
    , heading_rate(0.0)
    , roll_rate(0.0)
    , pitch_rate(0.0)
    , body_rates_XVn()
    , body_accel_XVn()
    , latitude(0.0)
    , longitude(0.0)
    , altitude(0.0)
    , altitude_reference(0)
    , position_cov()
    , altitude_stddev(0.0)
    , velocity_NEU()
    , velocity_stddev_NEU()
    , current_NE()
    , current_stddev_NE()
    , day(0)
    , month(0)
    , year(0)
    , sensor_status()
    , ins_algo_status()
    , ins_system_status()
    , ins_user_status(0)
    , ahrs_algo_status(0)
    , ahrs_system_status()
    , ahrs_user_status(0)
    , heaveSurgeSway_speed_XVnH()
    , body_velocity_XVn()
    , geo_accel_NEU()
    , course_over_ground(0.0)
    , speed_over_ground(0.0)
    , temp_avg_fog(0.0)
    , temp_avg_acc(0.0)
    , temp_board(0.0)
    , attitude_quaternion()
    , attitude_quaternion_stddev()
    , raw_accel_XVn()
    , body_accel_stddev_XVn()
    , body_rotrate_stddev_XVn()
    , raw_rot_acc_XVn()
    , raw_rot_acc_stddev_XVn()
    , raw_rot_rate_XVn()  {
  (void)_alloc;
      rt_heave_XVnH.assign(0.0);

      body_rates_XVn.assign(0.0);

      body_accel_XVn.assign(0.0);

      position_cov.assign(0.0);

      velocity_NEU.assign(0.0);

      velocity_stddev_NEU.assign(0.0);

      current_NE.assign(0.0);

      current_stddev_NE.assign(0.0);

      sensor_status.assign(0);

      ins_algo_status.assign(0);

      ins_system_status.assign(0);

      ahrs_system_status.assign(0);

      heaveSurgeSway_speed_XVnH.assign(0.0);

      body_velocity_XVn.assign(0.0);

      geo_accel_NEU.assign(0.0);

      attitude_quaternion.assign(0.0);

      attitude_quaternion_stddev.assign(0.0);

      raw_accel_XVn.assign(0.0);

      body_accel_stddev_XVn.assign(0.0);

      body_rotrate_stddev_XVn.assign(0.0);

      raw_rot_acc_XVn.assign(0.0);

      raw_rot_acc_stddev_XVn.assign(0.0);

      raw_rot_rate_XVn.assign(0.0);
  }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef  ::ds_core_msgs::DsHeader_<ContainerAllocator>  _ds_header_type;
  _ds_header_type ds_header;

   typedef uint32_t _nav_fields_type;
  _nav_fields_type nav_fields;

   typedef uint32_t _extended_nav_fields_type;
  _extended_nav_fields_type extended_nav_fields;

   typedef uint32_t _external_data_fields_type;
  _external_data_fields_type external_data_fields;

   typedef double _nav_validity_time_type;
  _nav_validity_time_type nav_validity_time;

   typedef uint32_t _counter_type;
  _counter_type counter;

   typedef float _heading_type;
  _heading_type heading;

   typedef float _roll_type;
  _roll_type roll;

   typedef float _pitch_type;
  _pitch_type pitch;

   typedef float _heading_stddev_type;
  _heading_stddev_type heading_stddev;

   typedef float _roll_stddev_type;
  _roll_stddev_type roll_stddev;

   typedef float _pitch_stddev_type;
  _pitch_stddev_type pitch_stddev;

   typedef boost::array<float, 3>  _rt_heave_XVnH_type;
  _rt_heave_XVnH_type rt_heave_XVnH;

   typedef double _smart_heave_validity_time_type;
  _smart_heave_validity_time_type smart_heave_validity_time;

   typedef float _smart_heave_type;
  _smart_heave_type smart_heave;

   typedef float _heading_rate_type;
  _heading_rate_type heading_rate;

   typedef float _roll_rate_type;
  _roll_rate_type roll_rate;

   typedef float _pitch_rate_type;
  _pitch_rate_type pitch_rate;

   typedef boost::array<float, 3>  _body_rates_XVn_type;
  _body_rates_XVn_type body_rates_XVn;

   typedef boost::array<float, 3>  _body_accel_XVn_type;
  _body_accel_XVn_type body_accel_XVn;

   typedef double _latitude_type;
  _latitude_type latitude;

   typedef double _longitude_type;
  _longitude_type longitude;

   typedef float _altitude_type;
  _altitude_type altitude;

   typedef uint8_t _altitude_reference_type;
  _altitude_reference_type altitude_reference;

   typedef boost::array<float, 4>  _position_cov_type;
  _position_cov_type position_cov;

   typedef float _altitude_stddev_type;
  _altitude_stddev_type altitude_stddev;

   typedef boost::array<float, 3>  _velocity_NEU_type;
  _velocity_NEU_type velocity_NEU;

   typedef boost::array<float, 3>  _velocity_stddev_NEU_type;
  _velocity_stddev_NEU_type velocity_stddev_NEU;

   typedef boost::array<float, 2>  _current_NE_type;
  _current_NE_type current_NE;

   typedef boost::array<float, 2>  _current_stddev_NE_type;
  _current_stddev_NE_type current_stddev_NE;

   typedef uint8_t _day_type;
  _day_type day;

   typedef uint8_t _month_type;
  _month_type month;

   typedef uint16_t _year_type;
  _year_type year;

   typedef boost::array<uint32_t, 2>  _sensor_status_type;
  _sensor_status_type sensor_status;

   typedef boost::array<uint32_t, 4>  _ins_algo_status_type;
  _ins_algo_status_type ins_algo_status;

   typedef boost::array<uint32_t, 3>  _ins_system_status_type;
  _ins_system_status_type ins_system_status;

   typedef uint32_t _ins_user_status_type;
  _ins_user_status_type ins_user_status;

   typedef uint32_t _ahrs_algo_status_type;
  _ahrs_algo_status_type ahrs_algo_status;

   typedef boost::array<uint32_t, 3>  _ahrs_system_status_type;
  _ahrs_system_status_type ahrs_system_status;

   typedef uint32_t _ahrs_user_status_type;
  _ahrs_user_status_type ahrs_user_status;

   typedef boost::array<float, 3>  _heaveSurgeSway_speed_XVnH_type;
  _heaveSurgeSway_speed_XVnH_type heaveSurgeSway_speed_XVnH;

   typedef boost::array<float, 3>  _body_velocity_XVn_type;
  _body_velocity_XVn_type body_velocity_XVn;

   typedef boost::array<float, 3>  _geo_accel_NEU_type;
  _geo_accel_NEU_type geo_accel_NEU;

   typedef float _course_over_ground_type;
  _course_over_ground_type course_over_ground;

   typedef float _speed_over_ground_type;
  _speed_over_ground_type speed_over_ground;

   typedef float _temp_avg_fog_type;
  _temp_avg_fog_type temp_avg_fog;

   typedef float _temp_avg_acc_type;
  _temp_avg_acc_type temp_avg_acc;

   typedef float _temp_board_type;
  _temp_board_type temp_board;

   typedef boost::array<float, 4>  _attitude_quaternion_type;
  _attitude_quaternion_type attitude_quaternion;

   typedef boost::array<float, 3>  _attitude_quaternion_stddev_type;
  _attitude_quaternion_stddev_type attitude_quaternion_stddev;

   typedef boost::array<float, 3>  _raw_accel_XVn_type;
  _raw_accel_XVn_type raw_accel_XVn;

   typedef boost::array<float, 3>  _body_accel_stddev_XVn_type;
  _body_accel_stddev_XVn_type body_accel_stddev_XVn;

   typedef boost::array<float, 3>  _body_rotrate_stddev_XVn_type;
  _body_rotrate_stddev_XVn_type body_rotrate_stddev_XVn;

   typedef boost::array<float, 3>  _raw_rot_acc_XVn_type;
  _raw_rot_acc_XVn_type raw_rot_acc_XVn;

   typedef boost::array<float, 3>  _raw_rot_acc_stddev_XVn_type;
  _raw_rot_acc_stddev_XVn_type raw_rot_acc_stddev_XVn;

   typedef boost::array<float, 3>  _raw_rot_rate_XVn_type;
  _raw_rot_rate_XVn_type raw_rot_rate_XVn;



// reducing the odds to have name collisions with Windows.h 
#if defined(_WIN32) && defined(ALTREF_GEOID)
  #undef ALTREF_GEOID
#endif
#if defined(_WIN32) && defined(ALTREF_ELLPS)
  #undef ALTREF_ELLPS
#endif

  enum {
    ALTREF_GEOID = 0u,
    ALTREF_ELLPS = 1u,
  };


  typedef boost::shared_ptr< ::ds_sensor_msgs::PhinsStdbin3_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::ds_sensor_msgs::PhinsStdbin3_<ContainerAllocator> const> ConstPtr;

}; // struct PhinsStdbin3_

typedef ::ds_sensor_msgs::PhinsStdbin3_<std::allocator<void> > PhinsStdbin3;

typedef boost::shared_ptr< ::ds_sensor_msgs::PhinsStdbin3 > PhinsStdbin3Ptr;
typedef boost::shared_ptr< ::ds_sensor_msgs::PhinsStdbin3 const> PhinsStdbin3ConstPtr;

// constants requiring out of line definition

   

   



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::ds_sensor_msgs::PhinsStdbin3_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::ds_sensor_msgs::PhinsStdbin3_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::ds_sensor_msgs::PhinsStdbin3_<ContainerAllocator1> & lhs, const ::ds_sensor_msgs::PhinsStdbin3_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.ds_header == rhs.ds_header &&
    lhs.nav_fields == rhs.nav_fields &&
    lhs.extended_nav_fields == rhs.extended_nav_fields &&
    lhs.external_data_fields == rhs.external_data_fields &&
    lhs.nav_validity_time == rhs.nav_validity_time &&
    lhs.counter == rhs.counter &&
    lhs.heading == rhs.heading &&
    lhs.roll == rhs.roll &&
    lhs.pitch == rhs.pitch &&
    lhs.heading_stddev == rhs.heading_stddev &&
    lhs.roll_stddev == rhs.roll_stddev &&
    lhs.pitch_stddev == rhs.pitch_stddev &&
    lhs.rt_heave_XVnH == rhs.rt_heave_XVnH &&
    lhs.smart_heave_validity_time == rhs.smart_heave_validity_time &&
    lhs.smart_heave == rhs.smart_heave &&
    lhs.heading_rate == rhs.heading_rate &&
    lhs.roll_rate == rhs.roll_rate &&
    lhs.pitch_rate == rhs.pitch_rate &&
    lhs.body_rates_XVn == rhs.body_rates_XVn &&
    lhs.body_accel_XVn == rhs.body_accel_XVn &&
    lhs.latitude == rhs.latitude &&
    lhs.longitude == rhs.longitude &&
    lhs.altitude == rhs.altitude &&
    lhs.altitude_reference == rhs.altitude_reference &&
    lhs.position_cov == rhs.position_cov &&
    lhs.altitude_stddev == rhs.altitude_stddev &&
    lhs.velocity_NEU == rhs.velocity_NEU &&
    lhs.velocity_stddev_NEU == rhs.velocity_stddev_NEU &&
    lhs.current_NE == rhs.current_NE &&
    lhs.current_stddev_NE == rhs.current_stddev_NE &&
    lhs.day == rhs.day &&
    lhs.month == rhs.month &&
    lhs.year == rhs.year &&
    lhs.sensor_status == rhs.sensor_status &&
    lhs.ins_algo_status == rhs.ins_algo_status &&
    lhs.ins_system_status == rhs.ins_system_status &&
    lhs.ins_user_status == rhs.ins_user_status &&
    lhs.ahrs_algo_status == rhs.ahrs_algo_status &&
    lhs.ahrs_system_status == rhs.ahrs_system_status &&
    lhs.ahrs_user_status == rhs.ahrs_user_status &&
    lhs.heaveSurgeSway_speed_XVnH == rhs.heaveSurgeSway_speed_XVnH &&
    lhs.body_velocity_XVn == rhs.body_velocity_XVn &&
    lhs.geo_accel_NEU == rhs.geo_accel_NEU &&
    lhs.course_over_ground == rhs.course_over_ground &&
    lhs.speed_over_ground == rhs.speed_over_ground &&
    lhs.temp_avg_fog == rhs.temp_avg_fog &&
    lhs.temp_avg_acc == rhs.temp_avg_acc &&
    lhs.temp_board == rhs.temp_board &&
    lhs.attitude_quaternion == rhs.attitude_quaternion &&
    lhs.attitude_quaternion_stddev == rhs.attitude_quaternion_stddev &&
    lhs.raw_accel_XVn == rhs.raw_accel_XVn &&
    lhs.body_accel_stddev_XVn == rhs.body_accel_stddev_XVn &&
    lhs.body_rotrate_stddev_XVn == rhs.body_rotrate_stddev_XVn &&
    lhs.raw_rot_acc_XVn == rhs.raw_rot_acc_XVn &&
    lhs.raw_rot_acc_stddev_XVn == rhs.raw_rot_acc_stddev_XVn &&
    lhs.raw_rot_rate_XVn == rhs.raw_rot_rate_XVn;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::ds_sensor_msgs::PhinsStdbin3_<ContainerAllocator1> & lhs, const ::ds_sensor_msgs::PhinsStdbin3_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace ds_sensor_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::ds_sensor_msgs::PhinsStdbin3_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::ds_sensor_msgs::PhinsStdbin3_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::ds_sensor_msgs::PhinsStdbin3_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::ds_sensor_msgs::PhinsStdbin3_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::ds_sensor_msgs::PhinsStdbin3_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::ds_sensor_msgs::PhinsStdbin3_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::ds_sensor_msgs::PhinsStdbin3_<ContainerAllocator> >
{
  static const char* value()
  {
    return "43569f5d1f6be2bb19fb99698943aa05";
  }

  static const char* value(const ::ds_sensor_msgs::PhinsStdbin3_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x43569f5d1f6be2bbULL;
  static const uint64_t static_value2 = 0x19fb99698943aa05ULL;
};

template<class ContainerAllocator>
struct DataType< ::ds_sensor_msgs::PhinsStdbin3_<ContainerAllocator> >
{
  static const char* value()
  {
    return "ds_sensor_msgs/PhinsStdbin3";
  }

  static const char* value(const ::ds_sensor_msgs::PhinsStdbin3_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::ds_sensor_msgs::PhinsStdbin3_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# The standard 2-part DsHeader block\n"
"# This allows both a standard ROS header and DS-specific header blocks\n"
"# See HEADERS.md in ds_core_msgs for details\n"
"std_msgs/Header header\n"
"ds_core_msgs/DsHeader ds_header\n"
"\n"
"# This includes as much data from the Phins STDBIN Version 3 binary message.\n"
"# See the document 7-INS-InterfaceLibrary_MU-INSIII-AN-001-U.pdf for details on this\n"
"# format.  Where possible, the coordinate system for each field has been included in the\n"
"# field.  XV(1,2,3) are the body-frame.  XV(1,2,3)H are a body-centered local/level frame.\n"
"# East, North, Up, and Down are geographic.  Where possible, units are\n"
"# meters, meters/sec, degrees, degrees per second, etc.\n"
"\n"
"# We include a couple header fields so at least w know what might be valid\n"
"uint32 nav_fields\n"
"uint32 extended_nav_fields\n"
"uint32 external_data_fields\n"
"float64 nav_validity_time\n"
"uint32 counter\n"
"\n"
"# Heading, pitch, and roll have their own definitions\n"
"float32 heading\n"
"float32 roll\n"
"float32 pitch\n"
"float32 heading_stddev\n"
"float32 roll_stddev\n"
"float32 pitch_stddev\n"
"\n"
"# Real-time heave at the selected lever-arm, in meters\n"
"float32[3] rt_heave_XVnH\n"
"\n"
"# Time of validity for smart heave, in seconds\n"
"float64 smart_heave_validity_time\n"
"\n"
"# Smart heave, at primary lever-arm.  Meters, positive up, XV3H\n"
"float32 smart_heave\n"
"\n"
"# Heading, pitch, and roll rate.  Degrees / s\n"
"float32 heading_rate\n"
"float32 roll_rate\n"
"float32 pitch_rate\n"
"\n"
"# Body rotation rates, degrees/s\n"
"float32[3] body_rates_XVn\n"
"\n"
"# Body-frame accelerations at the primary lever-arm, m/s^2\n"
"# Corrected for gravity and Coriolois\n"
"float32[3] body_accel_XVn\n"
"\n"
"# Lat/lon in degrees\n"
"float64 latitude\n"
"float64 longitude\n"
"\n"
"# Altitude in meters, positive up.  Referenced as shown in reference field\n"
"float32 altitude\n"
"uint8 altitude_reference\n"
"uint8 ALTREF_GEOID = 0\n"
"uint8 ALTREF_ELLPS = 1\n"
"\n"
"# Position covariance matrix, meters, row-major (doesnt' matter really...)\n"
"# north first\n"
"float32[4] position_cov\n"
"float32 altitude_stddev\n"
"\n"
"# Geographic velocity, m/s, north/east/up\n"
"float32[3] velocity_NEU\n"
"float32[3] velocity_stddev_NEU\n"
"\n"
"# Geographic current estimate, m/s, north/east\n"
"float32[2] current_NE\n"
"float32[2] current_stddev_NE\n"
"\n"
"uint8 day\n"
"uint8 month\n"
"uint16 year\n"
"\n"
"# Status words are recorded, but not decoded.  Refer to the manual for details\n"
"uint32[2] sensor_status\n"
"uint32[4] ins_algo_status\n"
"uint32[3] ins_system_status\n"
"uint32 ins_user_status\n"
"uint32 ahrs_algo_status\n"
"uint32[3] ahrs_system_status\n"
"uint32 ahrs_user_status\n"
"\n"
"# m/s.  Note we put in the order 1-2-3, NOT the XV3H order shown in the manual\n"
"float32[3] heaveSurgeSway_speed_XVnH\n"
"\n"
"# Body-frame velocity, primary lever-arm\n"
"float32[3] body_velocity_XVn\n"
"\n"
"# Geographic frame accelerations, primary lever-arm.  m/s^2.  Not compensated for gravity.\n"
"# North East Up\n"
"float32[3] geo_accel_NEU\n"
"\n"
"# degrees\n"
"float32 course_over_ground\n"
"\n"
"# m/s\n"
"float32 speed_over_ground\n"
"\n"
"# Average FOG temperature, deg C\n"
"float32 temp_avg_fog\n"
"\n"
"# Average Accelerometer temperature, deg C\n"
"float32 temp_avg_acc\n"
"\n"
"# Sensor Board temperature, deg C\n"
"float32 temp_board\n"
"\n"
"# The attitude quaternion may or may not conform to the ROS standard\n"
"# Until that's determined, it stays a float32[4]\n"
"float32[4] attitude_quaternion\n"
"float32[3] attitude_quaternion_stddev\n"
"\n"
"# Raw body-frame accelerations, m/s^2.  VERY quantized on non-export-controlled Phins.\n"
"float32[3] raw_accel_XVn\n"
"\n"
"# Body-frame acceleration stddev, m/s^2\n"
"float32[3] body_accel_stddev_XVn\n"
"\n"
"# Body-frame rotation rate standard deviation\n"
"float32[3] body_rotrate_stddev_XVn\n"
"\n"
"# Raw body-rate rotation acceleration\n"
"float32[3] raw_rot_acc_XVn\n"
"float32[3] raw_rot_acc_stddev_XVn\n"
"\n"
"# Raw vessel-frame rotation rate, not compensated for earth rate.  Quantized on\n"
"# non-export-controlled Phins\n"
"float32[3] raw_rot_rate_XVn\n"
"\n"
"\n"
"\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
"\n"
"================================================================================\n"
"MSG: ds_core_msgs/DsHeader\n"
"# This is half our standard header for ds_msgs; see\n"
"# HEADERS.md for details\n"
"\n"
"# This header should ALWAYS be paired with a std_msgs/Header\n"
"# and should ALWAYS reference HEADERS.md.  If you're looking at this\n"
"# file to add headers to a type, you probably want to copy/paste\n"
"# the following block:\n"
"#\n"
"#     # The standard 2-part DsHeader block\n"
"#     # This allows both a standard ROS header and DS-specific header blocks\n"
"#     # See HEADERS.md in ds_core_msgs for details\n"
"#     std_msgs/Header header\n"
"#     ds_core_msgs/DsHeader ds_header\n"
"#\n"
"\n"
"# Time data was received or sent out (i/o time)\n"
"time io_time\n"
"\n"
"# Sensor source UUID\n"
"uint8[16] source_uuid\n"
"\n"
;
  }

  static const char* value(const ::ds_sensor_msgs::PhinsStdbin3_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::ds_sensor_msgs::PhinsStdbin3_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.ds_header);
      stream.next(m.nav_fields);
      stream.next(m.extended_nav_fields);
      stream.next(m.external_data_fields);
      stream.next(m.nav_validity_time);
      stream.next(m.counter);
      stream.next(m.heading);
      stream.next(m.roll);
      stream.next(m.pitch);
      stream.next(m.heading_stddev);
      stream.next(m.roll_stddev);
      stream.next(m.pitch_stddev);
      stream.next(m.rt_heave_XVnH);
      stream.next(m.smart_heave_validity_time);
      stream.next(m.smart_heave);
      stream.next(m.heading_rate);
      stream.next(m.roll_rate);
      stream.next(m.pitch_rate);
      stream.next(m.body_rates_XVn);
      stream.next(m.body_accel_XVn);
      stream.next(m.latitude);
      stream.next(m.longitude);
      stream.next(m.altitude);
      stream.next(m.altitude_reference);
      stream.next(m.position_cov);
      stream.next(m.altitude_stddev);
      stream.next(m.velocity_NEU);
      stream.next(m.velocity_stddev_NEU);
      stream.next(m.current_NE);
      stream.next(m.current_stddev_NE);
      stream.next(m.day);
      stream.next(m.month);
      stream.next(m.year);
      stream.next(m.sensor_status);
      stream.next(m.ins_algo_status);
      stream.next(m.ins_system_status);
      stream.next(m.ins_user_status);
      stream.next(m.ahrs_algo_status);
      stream.next(m.ahrs_system_status);
      stream.next(m.ahrs_user_status);
      stream.next(m.heaveSurgeSway_speed_XVnH);
      stream.next(m.body_velocity_XVn);
      stream.next(m.geo_accel_NEU);
      stream.next(m.course_over_ground);
      stream.next(m.speed_over_ground);
      stream.next(m.temp_avg_fog);
      stream.next(m.temp_avg_acc);
      stream.next(m.temp_board);
      stream.next(m.attitude_quaternion);
      stream.next(m.attitude_quaternion_stddev);
      stream.next(m.raw_accel_XVn);
      stream.next(m.body_accel_stddev_XVn);
      stream.next(m.body_rotrate_stddev_XVn);
      stream.next(m.raw_rot_acc_XVn);
      stream.next(m.raw_rot_acc_stddev_XVn);
      stream.next(m.raw_rot_rate_XVn);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct PhinsStdbin3_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::ds_sensor_msgs::PhinsStdbin3_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::ds_sensor_msgs::PhinsStdbin3_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "ds_header: ";
    s << std::endl;
    Printer< ::ds_core_msgs::DsHeader_<ContainerAllocator> >::stream(s, indent + "  ", v.ds_header);
    s << indent << "nav_fields: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.nav_fields);
    s << indent << "extended_nav_fields: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.extended_nav_fields);
    s << indent << "external_data_fields: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.external_data_fields);
    s << indent << "nav_validity_time: ";
    Printer<double>::stream(s, indent + "  ", v.nav_validity_time);
    s << indent << "counter: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.counter);
    s << indent << "heading: ";
    Printer<float>::stream(s, indent + "  ", v.heading);
    s << indent << "roll: ";
    Printer<float>::stream(s, indent + "  ", v.roll);
    s << indent << "pitch: ";
    Printer<float>::stream(s, indent + "  ", v.pitch);
    s << indent << "heading_stddev: ";
    Printer<float>::stream(s, indent + "  ", v.heading_stddev);
    s << indent << "roll_stddev: ";
    Printer<float>::stream(s, indent + "  ", v.roll_stddev);
    s << indent << "pitch_stddev: ";
    Printer<float>::stream(s, indent + "  ", v.pitch_stddev);
    s << indent << "rt_heave_XVnH[]" << std::endl;
    for (size_t i = 0; i < v.rt_heave_XVnH.size(); ++i)
    {
      s << indent << "  rt_heave_XVnH[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.rt_heave_XVnH[i]);
    }
    s << indent << "smart_heave_validity_time: ";
    Printer<double>::stream(s, indent + "  ", v.smart_heave_validity_time);
    s << indent << "smart_heave: ";
    Printer<float>::stream(s, indent + "  ", v.smart_heave);
    s << indent << "heading_rate: ";
    Printer<float>::stream(s, indent + "  ", v.heading_rate);
    s << indent << "roll_rate: ";
    Printer<float>::stream(s, indent + "  ", v.roll_rate);
    s << indent << "pitch_rate: ";
    Printer<float>::stream(s, indent + "  ", v.pitch_rate);
    s << indent << "body_rates_XVn[]" << std::endl;
    for (size_t i = 0; i < v.body_rates_XVn.size(); ++i)
    {
      s << indent << "  body_rates_XVn[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.body_rates_XVn[i]);
    }
    s << indent << "body_accel_XVn[]" << std::endl;
    for (size_t i = 0; i < v.body_accel_XVn.size(); ++i)
    {
      s << indent << "  body_accel_XVn[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.body_accel_XVn[i]);
    }
    s << indent << "latitude: ";
    Printer<double>::stream(s, indent + "  ", v.latitude);
    s << indent << "longitude: ";
    Printer<double>::stream(s, indent + "  ", v.longitude);
    s << indent << "altitude: ";
    Printer<float>::stream(s, indent + "  ", v.altitude);
    s << indent << "altitude_reference: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.altitude_reference);
    s << indent << "position_cov[]" << std::endl;
    for (size_t i = 0; i < v.position_cov.size(); ++i)
    {
      s << indent << "  position_cov[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.position_cov[i]);
    }
    s << indent << "altitude_stddev: ";
    Printer<float>::stream(s, indent + "  ", v.altitude_stddev);
    s << indent << "velocity_NEU[]" << std::endl;
    for (size_t i = 0; i < v.velocity_NEU.size(); ++i)
    {
      s << indent << "  velocity_NEU[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.velocity_NEU[i]);
    }
    s << indent << "velocity_stddev_NEU[]" << std::endl;
    for (size_t i = 0; i < v.velocity_stddev_NEU.size(); ++i)
    {
      s << indent << "  velocity_stddev_NEU[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.velocity_stddev_NEU[i]);
    }
    s << indent << "current_NE[]" << std::endl;
    for (size_t i = 0; i < v.current_NE.size(); ++i)
    {
      s << indent << "  current_NE[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.current_NE[i]);
    }
    s << indent << "current_stddev_NE[]" << std::endl;
    for (size_t i = 0; i < v.current_stddev_NE.size(); ++i)
    {
      s << indent << "  current_stddev_NE[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.current_stddev_NE[i]);
    }
    s << indent << "day: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.day);
    s << indent << "month: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.month);
    s << indent << "year: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.year);
    s << indent << "sensor_status[]" << std::endl;
    for (size_t i = 0; i < v.sensor_status.size(); ++i)
    {
      s << indent << "  sensor_status[" << i << "]: ";
      Printer<uint32_t>::stream(s, indent + "  ", v.sensor_status[i]);
    }
    s << indent << "ins_algo_status[]" << std::endl;
    for (size_t i = 0; i < v.ins_algo_status.size(); ++i)
    {
      s << indent << "  ins_algo_status[" << i << "]: ";
      Printer<uint32_t>::stream(s, indent + "  ", v.ins_algo_status[i]);
    }
    s << indent << "ins_system_status[]" << std::endl;
    for (size_t i = 0; i < v.ins_system_status.size(); ++i)
    {
      s << indent << "  ins_system_status[" << i << "]: ";
      Printer<uint32_t>::stream(s, indent + "  ", v.ins_system_status[i]);
    }
    s << indent << "ins_user_status: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.ins_user_status);
    s << indent << "ahrs_algo_status: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.ahrs_algo_status);
    s << indent << "ahrs_system_status[]" << std::endl;
    for (size_t i = 0; i < v.ahrs_system_status.size(); ++i)
    {
      s << indent << "  ahrs_system_status[" << i << "]: ";
      Printer<uint32_t>::stream(s, indent + "  ", v.ahrs_system_status[i]);
    }
    s << indent << "ahrs_user_status: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.ahrs_user_status);
    s << indent << "heaveSurgeSway_speed_XVnH[]" << std::endl;
    for (size_t i = 0; i < v.heaveSurgeSway_speed_XVnH.size(); ++i)
    {
      s << indent << "  heaveSurgeSway_speed_XVnH[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.heaveSurgeSway_speed_XVnH[i]);
    }
    s << indent << "body_velocity_XVn[]" << std::endl;
    for (size_t i = 0; i < v.body_velocity_XVn.size(); ++i)
    {
      s << indent << "  body_velocity_XVn[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.body_velocity_XVn[i]);
    }
    s << indent << "geo_accel_NEU[]" << std::endl;
    for (size_t i = 0; i < v.geo_accel_NEU.size(); ++i)
    {
      s << indent << "  geo_accel_NEU[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.geo_accel_NEU[i]);
    }
    s << indent << "course_over_ground: ";
    Printer<float>::stream(s, indent + "  ", v.course_over_ground);
    s << indent << "speed_over_ground: ";
    Printer<float>::stream(s, indent + "  ", v.speed_over_ground);
    s << indent << "temp_avg_fog: ";
    Printer<float>::stream(s, indent + "  ", v.temp_avg_fog);
    s << indent << "temp_avg_acc: ";
    Printer<float>::stream(s, indent + "  ", v.temp_avg_acc);
    s << indent << "temp_board: ";
    Printer<float>::stream(s, indent + "  ", v.temp_board);
    s << indent << "attitude_quaternion[]" << std::endl;
    for (size_t i = 0; i < v.attitude_quaternion.size(); ++i)
    {
      s << indent << "  attitude_quaternion[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.attitude_quaternion[i]);
    }
    s << indent << "attitude_quaternion_stddev[]" << std::endl;
    for (size_t i = 0; i < v.attitude_quaternion_stddev.size(); ++i)
    {
      s << indent << "  attitude_quaternion_stddev[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.attitude_quaternion_stddev[i]);
    }
    s << indent << "raw_accel_XVn[]" << std::endl;
    for (size_t i = 0; i < v.raw_accel_XVn.size(); ++i)
    {
      s << indent << "  raw_accel_XVn[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.raw_accel_XVn[i]);
    }
    s << indent << "body_accel_stddev_XVn[]" << std::endl;
    for (size_t i = 0; i < v.body_accel_stddev_XVn.size(); ++i)
    {
      s << indent << "  body_accel_stddev_XVn[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.body_accel_stddev_XVn[i]);
    }
    s << indent << "body_rotrate_stddev_XVn[]" << std::endl;
    for (size_t i = 0; i < v.body_rotrate_stddev_XVn.size(); ++i)
    {
      s << indent << "  body_rotrate_stddev_XVn[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.body_rotrate_stddev_XVn[i]);
    }
    s << indent << "raw_rot_acc_XVn[]" << std::endl;
    for (size_t i = 0; i < v.raw_rot_acc_XVn.size(); ++i)
    {
      s << indent << "  raw_rot_acc_XVn[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.raw_rot_acc_XVn[i]);
    }
    s << indent << "raw_rot_acc_stddev_XVn[]" << std::endl;
    for (size_t i = 0; i < v.raw_rot_acc_stddev_XVn.size(); ++i)
    {
      s << indent << "  raw_rot_acc_stddev_XVn[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.raw_rot_acc_stddev_XVn[i]);
    }
    s << indent << "raw_rot_rate_XVn[]" << std::endl;
    for (size_t i = 0; i < v.raw_rot_rate_XVn.size(); ++i)
    {
      s << indent << "  raw_rot_rate_XVn[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.raw_rot_rate_XVn[i]);
    }
  }
};

} // namespace message_operations
} // namespace ros

#endif // DS_SENSOR_MSGS_MESSAGE_PHINSSTDBIN3_H
