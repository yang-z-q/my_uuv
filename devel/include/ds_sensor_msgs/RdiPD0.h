// Generated by gencpp from file ds_sensor_msgs/RdiPD0.msg
// DO NOT EDIT!


#ifndef DS_SENSOR_MSGS_MESSAGE_RDIPD0_H
#define DS_SENSOR_MSGS_MESSAGE_RDIPD0_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>
#include <ds_core_msgs/DsHeader.h>

namespace ds_sensor_msgs
{
template <class ContainerAllocator>
struct RdiPD0_
{
  typedef RdiPD0_<ContainerAllocator> Type;

  RdiPD0_()
    : header()
    , ds_header()
    , dvl_type(0)
    , altitude_sum(0.0)
    , speed_gnd(0.0)
    , course_gnd(0.0)
    , good_beams(0)
    , dvl_time(0.0)
    , fw_ver(0)
    , fw_rev(0)
    , config_khz(0)
    , carrier_frequency_hz(0)
    , config_convex(false)
    , config_sensornum(0)
    , config_xdcr(false)
    , config_up(false)
    , config_beamangle(0)
    , config_janus(0)
    , real_sim(0)
    , lag(0)
    , beams(0)
    , cells(0)
    , pings(0)
    , cell_depth(0)
    , blank(0)
    , signal_proc(0)
    , min_thresh(0)
    , code_reps(0)
    , min_good_pings(0)
    , good_thresh(0)
    , ping_interval()
    , coord_mode(0)
    , coord_tilts(false)
    , coord_3beam(false)
    , coord_binmapping(false)
    , hdng_align(0.0)
    , hdng_bias(0.0)
    , sensor_src(0)
    , sensor_avail(0)
    , bin1_dist(0.0)
    , xmit_pulse_len(0.0)
    , avg_start(0)
    , avg_end(0)
    , avg_false_thresh(0.0)
    , trans_lag_dist(0.0)
    , serial_num_cpu()
    , wb_cmd(0)
    , power(0)
    , serial_num(0)
    , beam_angle(0)
    , ensemble_num(0)
    , BIT(0)
    , rtc_time()
    , rtc_year(0)
    , rtc_month(0)
    , rtc_day(0)
    , rtc_hour(0)
    , rtc_minute(0)
    , rtc_second(0)
    , rtc_hundredth(0)
    , error_demod1(false)
    , error_demod0(false)
    , error_timingcard(false)
    , sound_vel(0)
    , depth(0.0)
    , heading(0.0)
    , pitch(0.0)
    , roll(0.0)
    , salinity(0)
    , temperature(0.0)
    , mpt_wait()
    , heading_std(0.0)
    , pitch_std(0.0)
    , roll_std(0.0)
    , adc()
    , error_busexception(false)
    , error_address(false)
    , error_illegalinstruction(false)
    , error_zerodivide(false)
    , error_emulator(false)
    , error_unassigned(false)
    , error_watchdogrestart(false)
    , error_batterysaver(false)
    , error_pinging(false)
    , error_coldwakeup(false)
    , error_unknwakeup(false)
    , error_clockread(false)
    , error_unexpectedalarm(false)
    , error_clockforward(false)
    , error_clockbackward(false)
    , error_powerfail(false)
    , error_interrupt4dsp(false)
    , error_interrupt5uart(false)
    , error_interrupt6clock(false)
    , error_interrupt7(false)
    , pressure(0.0)
    , pressure_variance(0.0)
    , y2k_time()
    , leak_valid(false)
    , leak_status(0)
    , leakA_detected(false)
    , leakA_open(false)
    , leakB_detected(false)
    , leakB_open(false)
    , leakA_raw(0)
    , leakB_raw(0)
    , tx_voltage(0.0)
    , tx_current(0.0)
    , transducer_impedence(0.0)
    , pings_per_ensemble(0)
    , delay(0)
    , corr_mag_min(0)
    , eval_amp_min(0)
    , percent_good_min(0)
    , mode(0)
    , err_vel_max(0)
    , range()
    , velocity()
    , correlation()
    , eval_amp()
    , percent_good()
    , ref_min(0)
    , ref_near(0.0)
    , ref_far(0.0)
    , ref_velocity()
    , ref_correlation()
    , ref_intensity()
    , ref_percent_good()
    , depth_max(0)
    , rssi_amp()
    , gain(0)
    , highres_valid(false)
    , highres_bt_velocity()
    , highres_bt_dmg()
    , highres_wm_velocity()
    , highres_wm_dmg()
    , highres_sound_vel(0.0)
    , btrange_valid(false)
    , btrange_slant_range(0.0)
    , btrange_axis_delta_range(0.0)
    , btrange_vertical_range(0.0)
    , btrange_pct_good_4beam(0)
    , btrange_pct_good_beam12(0)
    , btrange_pct_good_beam34(0)
    , btrange_raw_range()
    , btrange_max_filter()
    , btrange_max_amp()
    , navp_valid(false)
    , navp_time_to_bottom()
    , navp_bottomtrack_stddev()
    , navp_bottomtrack_valid_time()
    , navp_bottomtrack_shallow_mode(0)
    , navp_time_to_watermass()
    , navp_watertrack_stddev()
    , navp_watertrack_valid_time()
    , navp_watertrack_range(0.0)  {
      serial_num_cpu.assign(0);

      adc.assign(0);

      range.assign(0.0);

      velocity.assign(0.0);

      correlation.assign(0.0);

      eval_amp.assign(0);

      percent_good.assign(0);

      ref_velocity.assign(0);

      ref_correlation.assign(0);

      ref_intensity.assign(0.0);

      ref_percent_good.assign(0);

      rssi_amp.assign(0);

      highres_bt_velocity.assign(0.0);

      highres_bt_dmg.assign(0.0);

      highres_wm_velocity.assign(0.0);

      highres_wm_dmg.assign(0.0);

      btrange_raw_range.assign(0.0);

      btrange_max_filter.assign(0);

      btrange_max_amp.assign(0);

      navp_time_to_bottom.assign(0.0);

      navp_bottomtrack_stddev.assign(0.0);

      navp_bottomtrack_valid_time.assign(0.0);

      navp_time_to_watermass.assign(0.0);

      navp_watertrack_stddev.assign(0.0);

      navp_watertrack_valid_time.assign(0.0);
  }
  RdiPD0_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , ds_header(_alloc)
    , dvl_type(0)
    , altitude_sum(0.0)
    , speed_gnd(0.0)
    , course_gnd(0.0)
    , good_beams(0)
    , dvl_time(0.0)
    , fw_ver(0)
    , fw_rev(0)
    , config_khz(0)
    , carrier_frequency_hz(0)
    , config_convex(false)
    , config_sensornum(0)
    , config_xdcr(false)
    , config_up(false)
    , config_beamangle(0)
    , config_janus(0)
    , real_sim(0)
    , lag(0)
    , beams(0)
    , cells(0)
    , pings(0)
    , cell_depth(0)
    , blank(0)
    , signal_proc(0)
    , min_thresh(0)
    , code_reps(0)
    , min_good_pings(0)
    , good_thresh(0)
    , ping_interval()
    , coord_mode(0)
    , coord_tilts(false)
    , coord_3beam(false)
    , coord_binmapping(false)
    , hdng_align(0.0)
    , hdng_bias(0.0)
    , sensor_src(0)
    , sensor_avail(0)
    , bin1_dist(0.0)
    , xmit_pulse_len(0.0)
    , avg_start(0)
    , avg_end(0)
    , avg_false_thresh(0.0)
    , trans_lag_dist(0.0)
    , serial_num_cpu()
    , wb_cmd(0)
    , power(0)
    , serial_num(0)
    , beam_angle(0)
    , ensemble_num(0)
    , BIT(0)
    , rtc_time()
    , rtc_year(0)
    , rtc_month(0)
    , rtc_day(0)
    , rtc_hour(0)
    , rtc_minute(0)
    , rtc_second(0)
    , rtc_hundredth(0)
    , error_demod1(false)
    , error_demod0(false)
    , error_timingcard(false)
    , sound_vel(0)
    , depth(0.0)
    , heading(0.0)
    , pitch(0.0)
    , roll(0.0)
    , salinity(0)
    , temperature(0.0)
    , mpt_wait()
    , heading_std(0.0)
    , pitch_std(0.0)
    , roll_std(0.0)
    , adc()
    , error_busexception(false)
    , error_address(false)
    , error_illegalinstruction(false)
    , error_zerodivide(false)
    , error_emulator(false)
    , error_unassigned(false)
    , error_watchdogrestart(false)
    , error_batterysaver(false)
    , error_pinging(false)
    , error_coldwakeup(false)
    , error_unknwakeup(false)
    , error_clockread(false)
    , error_unexpectedalarm(false)
    , error_clockforward(false)
    , error_clockbackward(false)
    , error_powerfail(false)
    , error_interrupt4dsp(false)
    , error_interrupt5uart(false)
    , error_interrupt6clock(false)
    , error_interrupt7(false)
    , pressure(0.0)
    , pressure_variance(0.0)
    , y2k_time()
    , leak_valid(false)
    , leak_status(0)
    , leakA_detected(false)
    , leakA_open(false)
    , leakB_detected(false)
    , leakB_open(false)
    , leakA_raw(0)
    , leakB_raw(0)
    , tx_voltage(0.0)
    , tx_current(0.0)
    , transducer_impedence(0.0)
    , pings_per_ensemble(0)
    , delay(0)
    , corr_mag_min(0)
    , eval_amp_min(0)
    , percent_good_min(0)
    , mode(0)
    , err_vel_max(0)
    , range()
    , velocity()
    , correlation()
    , eval_amp()
    , percent_good()
    , ref_min(0)
    , ref_near(0.0)
    , ref_far(0.0)
    , ref_velocity()
    , ref_correlation()
    , ref_intensity()
    , ref_percent_good()
    , depth_max(0)
    , rssi_amp()
    , gain(0)
    , highres_valid(false)
    , highres_bt_velocity()
    , highres_bt_dmg()
    , highres_wm_velocity()
    , highres_wm_dmg()
    , highres_sound_vel(0.0)
    , btrange_valid(false)
    , btrange_slant_range(0.0)
    , btrange_axis_delta_range(0.0)
    , btrange_vertical_range(0.0)
    , btrange_pct_good_4beam(0)
    , btrange_pct_good_beam12(0)
    , btrange_pct_good_beam34(0)
    , btrange_raw_range()
    , btrange_max_filter()
    , btrange_max_amp()
    , navp_valid(false)
    , navp_time_to_bottom()
    , navp_bottomtrack_stddev()
    , navp_bottomtrack_valid_time()
    , navp_bottomtrack_shallow_mode(0)
    , navp_time_to_watermass()
    , navp_watertrack_stddev()
    , navp_watertrack_valid_time()
    , navp_watertrack_range(0.0)  {
  (void)_alloc;
      serial_num_cpu.assign(0);

      adc.assign(0);

      range.assign(0.0);

      velocity.assign(0.0);

      correlation.assign(0.0);

      eval_amp.assign(0);

      percent_good.assign(0);

      ref_velocity.assign(0);

      ref_correlation.assign(0);

      ref_intensity.assign(0.0);

      ref_percent_good.assign(0);

      rssi_amp.assign(0);

      highres_bt_velocity.assign(0.0);

      highres_bt_dmg.assign(0.0);

      highres_wm_velocity.assign(0.0);

      highres_wm_dmg.assign(0.0);

      btrange_raw_range.assign(0.0);

      btrange_max_filter.assign(0);

      btrange_max_amp.assign(0);

      navp_time_to_bottom.assign(0.0);

      navp_bottomtrack_stddev.assign(0.0);

      navp_bottomtrack_valid_time.assign(0.0);

      navp_time_to_watermass.assign(0.0);

      navp_watertrack_stddev.assign(0.0);

      navp_watertrack_valid_time.assign(0.0);
  }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef  ::ds_core_msgs::DsHeader_<ContainerAllocator>  _ds_header_type;
  _ds_header_type ds_header;

   typedef uint8_t _dvl_type_type;
  _dvl_type_type dvl_type;

   typedef double _altitude_sum_type;
  _altitude_sum_type altitude_sum;

   typedef double _speed_gnd_type;
  _speed_gnd_type speed_gnd;

   typedef double _course_gnd_type;
  _course_gnd_type course_gnd;

   typedef uint8_t _good_beams_type;
  _good_beams_type good_beams;

   typedef double _dvl_time_type;
  _dvl_time_type dvl_time;

   typedef uint8_t _fw_ver_type;
  _fw_ver_type fw_ver;

   typedef uint8_t _fw_rev_type;
  _fw_rev_type fw_rev;

   typedef uint32_t _config_khz_type;
  _config_khz_type config_khz;

   typedef uint32_t _carrier_frequency_hz_type;
  _carrier_frequency_hz_type carrier_frequency_hz;

   typedef uint8_t _config_convex_type;
  _config_convex_type config_convex;

   typedef uint8_t _config_sensornum_type;
  _config_sensornum_type config_sensornum;

   typedef uint8_t _config_xdcr_type;
  _config_xdcr_type config_xdcr;

   typedef uint8_t _config_up_type;
  _config_up_type config_up;

   typedef uint16_t _config_beamangle_type;
  _config_beamangle_type config_beamangle;

   typedef uint8_t _config_janus_type;
  _config_janus_type config_janus;

   typedef uint8_t _real_sim_type;
  _real_sim_type real_sim;

   typedef uint8_t _lag_type;
  _lag_type lag;

   typedef uint8_t _beams_type;
  _beams_type beams;

   typedef uint8_t _cells_type;
  _cells_type cells;

   typedef uint16_t _pings_type;
  _pings_type pings;

   typedef uint16_t _cell_depth_type;
  _cell_depth_type cell_depth;

   typedef uint16_t _blank_type;
  _blank_type blank;

   typedef uint8_t _signal_proc_type;
  _signal_proc_type signal_proc;

   typedef uint8_t _min_thresh_type;
  _min_thresh_type min_thresh;

   typedef uint8_t _code_reps_type;
  _code_reps_type code_reps;

   typedef uint8_t _min_good_pings_type;
  _min_good_pings_type min_good_pings;

   typedef uint16_t _good_thresh_type;
  _good_thresh_type good_thresh;

   typedef ros::Duration _ping_interval_type;
  _ping_interval_type ping_interval;

   typedef uint8_t _coord_mode_type;
  _coord_mode_type coord_mode;

   typedef uint8_t _coord_tilts_type;
  _coord_tilts_type coord_tilts;

   typedef uint8_t _coord_3beam_type;
  _coord_3beam_type coord_3beam;

   typedef uint8_t _coord_binmapping_type;
  _coord_binmapping_type coord_binmapping;

   typedef double _hdng_align_type;
  _hdng_align_type hdng_align;

   typedef double _hdng_bias_type;
  _hdng_bias_type hdng_bias;

   typedef uint8_t _sensor_src_type;
  _sensor_src_type sensor_src;

   typedef uint8_t _sensor_avail_type;
  _sensor_avail_type sensor_avail;

   typedef float _bin1_dist_type;
  _bin1_dist_type bin1_dist;

   typedef float _xmit_pulse_len_type;
  _xmit_pulse_len_type xmit_pulse_len;

   typedef uint8_t _avg_start_type;
  _avg_start_type avg_start;

   typedef uint8_t _avg_end_type;
  _avg_end_type avg_end;

   typedef float _avg_false_thresh_type;
  _avg_false_thresh_type avg_false_thresh;

   typedef float _trans_lag_dist_type;
  _trans_lag_dist_type trans_lag_dist;

   typedef boost::array<uint8_t, 8>  _serial_num_cpu_type;
  _serial_num_cpu_type serial_num_cpu;

   typedef uint16_t _wb_cmd_type;
  _wb_cmd_type wb_cmd;

   typedef uint8_t _power_type;
  _power_type power;

   typedef uint32_t _serial_num_type;
  _serial_num_type serial_num;

   typedef uint8_t _beam_angle_type;
  _beam_angle_type beam_angle;

   typedef uint32_t _ensemble_num_type;
  _ensemble_num_type ensemble_num;

   typedef uint8_t _BIT_type;
  _BIT_type BIT;

   typedef ros::Time _rtc_time_type;
  _rtc_time_type rtc_time;

   typedef uint8_t _rtc_year_type;
  _rtc_year_type rtc_year;

   typedef uint8_t _rtc_month_type;
  _rtc_month_type rtc_month;

   typedef uint8_t _rtc_day_type;
  _rtc_day_type rtc_day;

   typedef uint8_t _rtc_hour_type;
  _rtc_hour_type rtc_hour;

   typedef uint8_t _rtc_minute_type;
  _rtc_minute_type rtc_minute;

   typedef uint8_t _rtc_second_type;
  _rtc_second_type rtc_second;

   typedef uint8_t _rtc_hundredth_type;
  _rtc_hundredth_type rtc_hundredth;

   typedef uint8_t _error_demod1_type;
  _error_demod1_type error_demod1;

   typedef uint8_t _error_demod0_type;
  _error_demod0_type error_demod0;

   typedef uint8_t _error_timingcard_type;
  _error_timingcard_type error_timingcard;

   typedef uint32_t _sound_vel_type;
  _sound_vel_type sound_vel;

   typedef double _depth_type;
  _depth_type depth;

   typedef double _heading_type;
  _heading_type heading;

   typedef double _pitch_type;
  _pitch_type pitch;

   typedef double _roll_type;
  _roll_type roll;

   typedef uint16_t _salinity_type;
  _salinity_type salinity;

   typedef double _temperature_type;
  _temperature_type temperature;

   typedef ros::Duration _mpt_wait_type;
  _mpt_wait_type mpt_wait;

   typedef double _heading_std_type;
  _heading_std_type heading_std;

   typedef double _pitch_std_type;
  _pitch_std_type pitch_std;

   typedef double _roll_std_type;
  _roll_std_type roll_std;

   typedef boost::array<uint8_t, 8>  _adc_type;
  _adc_type adc;

   typedef uint8_t _error_busexception_type;
  _error_busexception_type error_busexception;

   typedef uint8_t _error_address_type;
  _error_address_type error_address;

   typedef uint8_t _error_illegalinstruction_type;
  _error_illegalinstruction_type error_illegalinstruction;

   typedef uint8_t _error_zerodivide_type;
  _error_zerodivide_type error_zerodivide;

   typedef uint8_t _error_emulator_type;
  _error_emulator_type error_emulator;

   typedef uint8_t _error_unassigned_type;
  _error_unassigned_type error_unassigned;

   typedef uint8_t _error_watchdogrestart_type;
  _error_watchdogrestart_type error_watchdogrestart;

   typedef uint8_t _error_batterysaver_type;
  _error_batterysaver_type error_batterysaver;

   typedef uint8_t _error_pinging_type;
  _error_pinging_type error_pinging;

   typedef uint8_t _error_coldwakeup_type;
  _error_coldwakeup_type error_coldwakeup;

   typedef uint8_t _error_unknwakeup_type;
  _error_unknwakeup_type error_unknwakeup;

   typedef uint8_t _error_clockread_type;
  _error_clockread_type error_clockread;

   typedef uint8_t _error_unexpectedalarm_type;
  _error_unexpectedalarm_type error_unexpectedalarm;

   typedef uint8_t _error_clockforward_type;
  _error_clockforward_type error_clockforward;

   typedef uint8_t _error_clockbackward_type;
  _error_clockbackward_type error_clockbackward;

   typedef uint8_t _error_powerfail_type;
  _error_powerfail_type error_powerfail;

   typedef uint8_t _error_interrupt4dsp_type;
  _error_interrupt4dsp_type error_interrupt4dsp;

   typedef uint8_t _error_interrupt5uart_type;
  _error_interrupt5uart_type error_interrupt5uart;

   typedef uint8_t _error_interrupt6clock_type;
  _error_interrupt6clock_type error_interrupt6clock;

   typedef uint8_t _error_interrupt7_type;
  _error_interrupt7_type error_interrupt7;

   typedef double _pressure_type;
  _pressure_type pressure;

   typedef double _pressure_variance_type;
  _pressure_variance_type pressure_variance;

   typedef ros::Time _y2k_time_type;
  _y2k_time_type y2k_time;

   typedef uint8_t _leak_valid_type;
  _leak_valid_type leak_valid;

   typedef uint8_t _leak_status_type;
  _leak_status_type leak_status;

   typedef uint8_t _leakA_detected_type;
  _leakA_detected_type leakA_detected;

   typedef uint8_t _leakA_open_type;
  _leakA_open_type leakA_open;

   typedef uint8_t _leakB_detected_type;
  _leakB_detected_type leakB_detected;

   typedef uint8_t _leakB_open_type;
  _leakB_open_type leakB_open;

   typedef uint16_t _leakA_raw_type;
  _leakA_raw_type leakA_raw;

   typedef uint16_t _leakB_raw_type;
  _leakB_raw_type leakB_raw;

   typedef float _tx_voltage_type;
  _tx_voltage_type tx_voltage;

   typedef float _tx_current_type;
  _tx_current_type tx_current;

   typedef float _transducer_impedence_type;
  _transducer_impedence_type transducer_impedence;

   typedef uint16_t _pings_per_ensemble_type;
  _pings_per_ensemble_type pings_per_ensemble;

   typedef uint16_t _delay_type;
  _delay_type delay;

   typedef uint8_t _corr_mag_min_type;
  _corr_mag_min_type corr_mag_min;

   typedef uint8_t _eval_amp_min_type;
  _eval_amp_min_type eval_amp_min;

   typedef uint8_t _percent_good_min_type;
  _percent_good_min_type percent_good_min;

   typedef uint8_t _mode_type;
  _mode_type mode;

   typedef uint32_t _err_vel_max_type;
  _err_vel_max_type err_vel_max;

   typedef boost::array<float, 4>  _range_type;
  _range_type range;

   typedef boost::array<float, 4>  _velocity_type;
  _velocity_type velocity;

   typedef boost::array<float, 4>  _correlation_type;
  _correlation_type correlation;

   typedef boost::array<uint8_t, 4>  _eval_amp_type;
  _eval_amp_type eval_amp;

   typedef boost::array<uint8_t, 4>  _percent_good_type;
  _percent_good_type percent_good;

   typedef uint32_t _ref_min_type;
  _ref_min_type ref_min;

   typedef float _ref_near_type;
  _ref_near_type ref_near;

   typedef float _ref_far_type;
  _ref_far_type ref_far;

   typedef boost::array<int32_t, 4>  _ref_velocity_type;
  _ref_velocity_type ref_velocity;

   typedef boost::array<uint32_t, 4>  _ref_correlation_type;
  _ref_correlation_type ref_correlation;

   typedef boost::array<float, 4>  _ref_intensity_type;
  _ref_intensity_type ref_intensity;

   typedef boost::array<uint8_t, 4>  _ref_percent_good_type;
  _ref_percent_good_type ref_percent_good;

   typedef uint16_t _depth_max_type;
  _depth_max_type depth_max;

   typedef boost::array<uint32_t, 4>  _rssi_amp_type;
  _rssi_amp_type rssi_amp;

   typedef uint8_t _gain_type;
  _gain_type gain;

   typedef uint8_t _highres_valid_type;
  _highres_valid_type highres_valid;

   typedef boost::array<float, 4>  _highres_bt_velocity_type;
  _highres_bt_velocity_type highres_bt_velocity;

   typedef boost::array<float, 4>  _highres_bt_dmg_type;
  _highres_bt_dmg_type highres_bt_dmg;

   typedef boost::array<float, 4>  _highres_wm_velocity_type;
  _highres_wm_velocity_type highres_wm_velocity;

   typedef boost::array<float, 4>  _highres_wm_dmg_type;
  _highres_wm_dmg_type highres_wm_dmg;

   typedef float _highres_sound_vel_type;
  _highres_sound_vel_type highres_sound_vel;

   typedef uint8_t _btrange_valid_type;
  _btrange_valid_type btrange_valid;

   typedef float _btrange_slant_range_type;
  _btrange_slant_range_type btrange_slant_range;

   typedef float _btrange_axis_delta_range_type;
  _btrange_axis_delta_range_type btrange_axis_delta_range;

   typedef float _btrange_vertical_range_type;
  _btrange_vertical_range_type btrange_vertical_range;

   typedef uint8_t _btrange_pct_good_4beam_type;
  _btrange_pct_good_4beam_type btrange_pct_good_4beam;

   typedef uint8_t _btrange_pct_good_beam12_type;
  _btrange_pct_good_beam12_type btrange_pct_good_beam12;

   typedef uint8_t _btrange_pct_good_beam34_type;
  _btrange_pct_good_beam34_type btrange_pct_good_beam34;

   typedef boost::array<float, 4>  _btrange_raw_range_type;
  _btrange_raw_range_type btrange_raw_range;

   typedef boost::array<uint8_t, 4>  _btrange_max_filter_type;
  _btrange_max_filter_type btrange_max_filter;

   typedef boost::array<uint8_t, 4>  _btrange_max_amp_type;
  _btrange_max_amp_type btrange_max_amp;

   typedef uint8_t _navp_valid_type;
  _navp_valid_type navp_valid;

   typedef boost::array<float, 4>  _navp_time_to_bottom_type;
  _navp_time_to_bottom_type navp_time_to_bottom;

   typedef boost::array<float, 4>  _navp_bottomtrack_stddev_type;
  _navp_bottomtrack_stddev_type navp_bottomtrack_stddev;

   typedef boost::array<float, 4>  _navp_bottomtrack_valid_time_type;
  _navp_bottomtrack_valid_time_type navp_bottomtrack_valid_time;

   typedef uint8_t _navp_bottomtrack_shallow_mode_type;
  _navp_bottomtrack_shallow_mode_type navp_bottomtrack_shallow_mode;

   typedef boost::array<float, 4>  _navp_time_to_watermass_type;
  _navp_time_to_watermass_type navp_time_to_watermass;

   typedef boost::array<float, 4>  _navp_watertrack_stddev_type;
  _navp_watertrack_stddev_type navp_watertrack_stddev;

   typedef boost::array<float, 4>  _navp_watertrack_valid_time_type;
  _navp_watertrack_valid_time_type navp_watertrack_valid_time;

   typedef float _navp_watertrack_range_type;
  _navp_watertrack_range_type navp_watertrack_range;



// reducing the odds to have name collisions with Windows.h 
#if defined(_WIN32) && defined(DVL_TYPE_PISTON)
  #undef DVL_TYPE_PISTON
#endif
#if defined(_WIN32) && defined(DVL_TYPE_PHASED_ARRAY)
  #undef DVL_TYPE_PHASED_ARRAY
#endif
#if defined(_WIN32) && defined(NAVP_BT_MODE_DEEP)
  #undef NAVP_BT_MODE_DEEP
#endif
#if defined(_WIN32) && defined(NAVP_BT_MODE_SHALLOW)
  #undef NAVP_BT_MODE_SHALLOW
#endif

  enum {
    DVL_TYPE_PISTON = 0u,
    DVL_TYPE_PHASED_ARRAY = 1u,
    NAVP_BT_MODE_DEEP = 0u,
    NAVP_BT_MODE_SHALLOW = 1u,
  };


  typedef boost::shared_ptr< ::ds_sensor_msgs::RdiPD0_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::ds_sensor_msgs::RdiPD0_<ContainerAllocator> const> ConstPtr;

}; // struct RdiPD0_

typedef ::ds_sensor_msgs::RdiPD0_<std::allocator<void> > RdiPD0;

typedef boost::shared_ptr< ::ds_sensor_msgs::RdiPD0 > RdiPD0Ptr;
typedef boost::shared_ptr< ::ds_sensor_msgs::RdiPD0 const> RdiPD0ConstPtr;

// constants requiring out of line definition

   

   

   

   



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::ds_sensor_msgs::RdiPD0_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::ds_sensor_msgs::RdiPD0_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::ds_sensor_msgs::RdiPD0_<ContainerAllocator1> & lhs, const ::ds_sensor_msgs::RdiPD0_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.ds_header == rhs.ds_header &&
    lhs.dvl_type == rhs.dvl_type &&
    lhs.altitude_sum == rhs.altitude_sum &&
    lhs.speed_gnd == rhs.speed_gnd &&
    lhs.course_gnd == rhs.course_gnd &&
    lhs.good_beams == rhs.good_beams &&
    lhs.dvl_time == rhs.dvl_time &&
    lhs.fw_ver == rhs.fw_ver &&
    lhs.fw_rev == rhs.fw_rev &&
    lhs.config_khz == rhs.config_khz &&
    lhs.carrier_frequency_hz == rhs.carrier_frequency_hz &&
    lhs.config_convex == rhs.config_convex &&
    lhs.config_sensornum == rhs.config_sensornum &&
    lhs.config_xdcr == rhs.config_xdcr &&
    lhs.config_up == rhs.config_up &&
    lhs.config_beamangle == rhs.config_beamangle &&
    lhs.config_janus == rhs.config_janus &&
    lhs.real_sim == rhs.real_sim &&
    lhs.lag == rhs.lag &&
    lhs.beams == rhs.beams &&
    lhs.cells == rhs.cells &&
    lhs.pings == rhs.pings &&
    lhs.cell_depth == rhs.cell_depth &&
    lhs.blank == rhs.blank &&
    lhs.signal_proc == rhs.signal_proc &&
    lhs.min_thresh == rhs.min_thresh &&
    lhs.code_reps == rhs.code_reps &&
    lhs.min_good_pings == rhs.min_good_pings &&
    lhs.good_thresh == rhs.good_thresh &&
    lhs.ping_interval == rhs.ping_interval &&
    lhs.coord_mode == rhs.coord_mode &&
    lhs.coord_tilts == rhs.coord_tilts &&
    lhs.coord_3beam == rhs.coord_3beam &&
    lhs.coord_binmapping == rhs.coord_binmapping &&
    lhs.hdng_align == rhs.hdng_align &&
    lhs.hdng_bias == rhs.hdng_bias &&
    lhs.sensor_src == rhs.sensor_src &&
    lhs.sensor_avail == rhs.sensor_avail &&
    lhs.bin1_dist == rhs.bin1_dist &&
    lhs.xmit_pulse_len == rhs.xmit_pulse_len &&
    lhs.avg_start == rhs.avg_start &&
    lhs.avg_end == rhs.avg_end &&
    lhs.avg_false_thresh == rhs.avg_false_thresh &&
    lhs.trans_lag_dist == rhs.trans_lag_dist &&
    lhs.serial_num_cpu == rhs.serial_num_cpu &&
    lhs.wb_cmd == rhs.wb_cmd &&
    lhs.power == rhs.power &&
    lhs.serial_num == rhs.serial_num &&
    lhs.beam_angle == rhs.beam_angle &&
    lhs.ensemble_num == rhs.ensemble_num &&
    lhs.BIT == rhs.BIT &&
    lhs.rtc_time == rhs.rtc_time &&
    lhs.rtc_year == rhs.rtc_year &&
    lhs.rtc_month == rhs.rtc_month &&
    lhs.rtc_day == rhs.rtc_day &&
    lhs.rtc_hour == rhs.rtc_hour &&
    lhs.rtc_minute == rhs.rtc_minute &&
    lhs.rtc_second == rhs.rtc_second &&
    lhs.rtc_hundredth == rhs.rtc_hundredth &&
    lhs.error_demod1 == rhs.error_demod1 &&
    lhs.error_demod0 == rhs.error_demod0 &&
    lhs.error_timingcard == rhs.error_timingcard &&
    lhs.sound_vel == rhs.sound_vel &&
    lhs.depth == rhs.depth &&
    lhs.heading == rhs.heading &&
    lhs.pitch == rhs.pitch &&
    lhs.roll == rhs.roll &&
    lhs.salinity == rhs.salinity &&
    lhs.temperature == rhs.temperature &&
    lhs.mpt_wait == rhs.mpt_wait &&
    lhs.heading_std == rhs.heading_std &&
    lhs.pitch_std == rhs.pitch_std &&
    lhs.roll_std == rhs.roll_std &&
    lhs.adc == rhs.adc &&
    lhs.error_busexception == rhs.error_busexception &&
    lhs.error_address == rhs.error_address &&
    lhs.error_illegalinstruction == rhs.error_illegalinstruction &&
    lhs.error_zerodivide == rhs.error_zerodivide &&
    lhs.error_emulator == rhs.error_emulator &&
    lhs.error_unassigned == rhs.error_unassigned &&
    lhs.error_watchdogrestart == rhs.error_watchdogrestart &&
    lhs.error_batterysaver == rhs.error_batterysaver &&
    lhs.error_pinging == rhs.error_pinging &&
    lhs.error_coldwakeup == rhs.error_coldwakeup &&
    lhs.error_unknwakeup == rhs.error_unknwakeup &&
    lhs.error_clockread == rhs.error_clockread &&
    lhs.error_unexpectedalarm == rhs.error_unexpectedalarm &&
    lhs.error_clockforward == rhs.error_clockforward &&
    lhs.error_clockbackward == rhs.error_clockbackward &&
    lhs.error_powerfail == rhs.error_powerfail &&
    lhs.error_interrupt4dsp == rhs.error_interrupt4dsp &&
    lhs.error_interrupt5uart == rhs.error_interrupt5uart &&
    lhs.error_interrupt6clock == rhs.error_interrupt6clock &&
    lhs.error_interrupt7 == rhs.error_interrupt7 &&
    lhs.pressure == rhs.pressure &&
    lhs.pressure_variance == rhs.pressure_variance &&
    lhs.y2k_time == rhs.y2k_time &&
    lhs.leak_valid == rhs.leak_valid &&
    lhs.leak_status == rhs.leak_status &&
    lhs.leakA_detected == rhs.leakA_detected &&
    lhs.leakA_open == rhs.leakA_open &&
    lhs.leakB_detected == rhs.leakB_detected &&
    lhs.leakB_open == rhs.leakB_open &&
    lhs.leakA_raw == rhs.leakA_raw &&
    lhs.leakB_raw == rhs.leakB_raw &&
    lhs.tx_voltage == rhs.tx_voltage &&
    lhs.tx_current == rhs.tx_current &&
    lhs.transducer_impedence == rhs.transducer_impedence &&
    lhs.pings_per_ensemble == rhs.pings_per_ensemble &&
    lhs.delay == rhs.delay &&
    lhs.corr_mag_min == rhs.corr_mag_min &&
    lhs.eval_amp_min == rhs.eval_amp_min &&
    lhs.percent_good_min == rhs.percent_good_min &&
    lhs.mode == rhs.mode &&
    lhs.err_vel_max == rhs.err_vel_max &&
    lhs.range == rhs.range &&
    lhs.velocity == rhs.velocity &&
    lhs.correlation == rhs.correlation &&
    lhs.eval_amp == rhs.eval_amp &&
    lhs.percent_good == rhs.percent_good &&
    lhs.ref_min == rhs.ref_min &&
    lhs.ref_near == rhs.ref_near &&
    lhs.ref_far == rhs.ref_far &&
    lhs.ref_velocity == rhs.ref_velocity &&
    lhs.ref_correlation == rhs.ref_correlation &&
    lhs.ref_intensity == rhs.ref_intensity &&
    lhs.ref_percent_good == rhs.ref_percent_good &&
    lhs.depth_max == rhs.depth_max &&
    lhs.rssi_amp == rhs.rssi_amp &&
    lhs.gain == rhs.gain &&
    lhs.highres_valid == rhs.highres_valid &&
    lhs.highres_bt_velocity == rhs.highres_bt_velocity &&
    lhs.highres_bt_dmg == rhs.highres_bt_dmg &&
    lhs.highres_wm_velocity == rhs.highres_wm_velocity &&
    lhs.highres_wm_dmg == rhs.highres_wm_dmg &&
    lhs.highres_sound_vel == rhs.highres_sound_vel &&
    lhs.btrange_valid == rhs.btrange_valid &&
    lhs.btrange_slant_range == rhs.btrange_slant_range &&
    lhs.btrange_axis_delta_range == rhs.btrange_axis_delta_range &&
    lhs.btrange_vertical_range == rhs.btrange_vertical_range &&
    lhs.btrange_pct_good_4beam == rhs.btrange_pct_good_4beam &&
    lhs.btrange_pct_good_beam12 == rhs.btrange_pct_good_beam12 &&
    lhs.btrange_pct_good_beam34 == rhs.btrange_pct_good_beam34 &&
    lhs.btrange_raw_range == rhs.btrange_raw_range &&
    lhs.btrange_max_filter == rhs.btrange_max_filter &&
    lhs.btrange_max_amp == rhs.btrange_max_amp &&
    lhs.navp_valid == rhs.navp_valid &&
    lhs.navp_time_to_bottom == rhs.navp_time_to_bottom &&
    lhs.navp_bottomtrack_stddev == rhs.navp_bottomtrack_stddev &&
    lhs.navp_bottomtrack_valid_time == rhs.navp_bottomtrack_valid_time &&
    lhs.navp_bottomtrack_shallow_mode == rhs.navp_bottomtrack_shallow_mode &&
    lhs.navp_time_to_watermass == rhs.navp_time_to_watermass &&
    lhs.navp_watertrack_stddev == rhs.navp_watertrack_stddev &&
    lhs.navp_watertrack_valid_time == rhs.navp_watertrack_valid_time &&
    lhs.navp_watertrack_range == rhs.navp_watertrack_range;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::ds_sensor_msgs::RdiPD0_<ContainerAllocator1> & lhs, const ::ds_sensor_msgs::RdiPD0_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace ds_sensor_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::ds_sensor_msgs::RdiPD0_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::ds_sensor_msgs::RdiPD0_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::ds_sensor_msgs::RdiPD0_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::ds_sensor_msgs::RdiPD0_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::ds_sensor_msgs::RdiPD0_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::ds_sensor_msgs::RdiPD0_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::ds_sensor_msgs::RdiPD0_<ContainerAllocator> >
{
  static const char* value()
  {
    return "f798d30dd811f4b9295fc2ce59ff6c2d";
  }

  static const char* value(const ::ds_sensor_msgs::RdiPD0_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xf798d30dd811f4b9ULL;
  static const uint64_t static_value2 = 0x295fc2ce59ff6c2dULL;
};

template<class ContainerAllocator>
struct DataType< ::ds_sensor_msgs::RdiPD0_<ContainerAllocator> >
{
  static const char* value()
  {
    return "ds_sensor_msgs/RdiPD0";
  }

  static const char* value(const ::ds_sensor_msgs::RdiPD0_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::ds_sensor_msgs::RdiPD0_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# The standard 2-part DsHeader block\n"
"# This allows both a standard ROS header and DS-specific header blocks\n"
"# See HEADERS.md in ds_core_msgs for details\n"
"std_msgs/Header header\n"
"ds_core_msgs/DsHeader ds_header\n"
"\n"
"################################\n"
"# Standard DVL type disclaimer #\n"
"################################\n"
"\n"
"# Standard array with one piston transducer for each beam\n"
"# If you have 4-5 individual disks on your DVL, use this one.\n"
"# Examples include Sonardyne Syrinx, Nortek DVLs, and RDI Workhorse\n"
"uint8 DVL_TYPE_PISTON=0\n"
"\n"
"# Newfangled phased-array DVL.  If you have one giant disk with complicated stuff on it,\n"
"# probably this one.\n"
"# Examples include newer RDI DVLs such as pathfinder, pioneer, and tasman.\n"
"uint8 DVL_TYPE_PHASED_ARRAY=1\n"
"\n"
"# Type of DVL array employed (see above).  Necessary when\n"
"# deciding how to apply sound velocity corrections\n"
"uint8 dvl_type\n"
"\n"
"#################\n"
"# DVL processed #\n"
"#################\n"
"\n"
"float64 altitude_sum\n"
"float64 speed_gnd\n"
"float64 course_gnd\n"
"uint8 good_beams\n"
"float64 dvl_time\n"
"\n"
"####################\n"
"# DVL fixed leader #\n"
"####################\n"
"\n"
"# Units: Distances [cm]; Velocities [mm/s]; Angles [deg/100]\n"
"\n"
"uint8 fw_ver\n"
"uint8 fw_rev\n"
"uint32 config_khz       #75, 150, 300, or 600\n"
"uint32 carrier_frequency_hz\n"
"bool config_convex      #1 for convex, 0 for concave\n"
"uint8 config_sensornum  #1, 2, or 3\n"
"bool config_xdcr        #1 for attached, 0 for unattached\n"
"bool config_up          #1 for up, 0 for down\n"
"uint16 config_beamangle #15E, 20E, 30E, or 0 for other\n"
"uint8 config_janus      #4 for 4 beam, 5 for 5 beam demod, 15 for 5 beam 2 demod\n"
"uint8 real_sim          #0=real is default\n"
"uint8 lag\n"
"uint8 beams\n"
"uint8 cells\n"
"uint16 pings\n"
"uint16 cell_depth\n"
"uint16 blank\n"
"uint8 signal_proc       #Always =1\n"
"uint8 min_thresh\n"
"uint8 code_reps\n"
"uint8 min_good_pings\n"
"uint16 good_thresh\n"
"\n"
"duration ping_interval  #Time between ping intervals\n"
"uint8 coord_mode\n"
"bool coord_tilts\n"
"bool coord_3beam\n"
"bool coord_binmapping\n"
"float64 hdng_align      #ea-command\n"
"float64 hdng_bias       #eb-command\n"
"uint8 sensor_src        #ez-command\n"
"uint8 sensor_avail      #same as sensor_src pattern\n"
"float32 bin1_dist\n"
"float32 xmit_pulse_len\n"
"uint8 avg_start\n"
"uint8 avg_end\n"
"float32 avg_false_thresh\n"
"float32 trans_lag_dist\n"
"uint8[8] serial_num_cpu\n"
"uint16 wb_cmd           #THESE ENTRIES MAY NOT BE VALID\n"
"uint8 power             #THESE ENTRIES MAY NOT BE VALID\n"
"uint32 serial_num       #THESE ENTRIES MAY NOT BE VALID\n"
"uint8 beam_angle        #THESE ENTRIES MAY NOT BE VALID\n"
"\n"
"\n"
"#######################\n"
"# DVL variable leader #\n"
"#######################\n"
"\n"
"# Units: Hdg, Pitch, Roll [deg],  P [Pa],  dt [s],  Xdepth [m],  Cs [m/s],  S [ppt]\n"
"\n"
"uint32 ensemble_num\n"
"uint8 BIT\n"
"\n"
"time rtc_time           #Real-time clock for current data ensemble\n"
"uint8 rtc_year\n"
"uint8 rtc_month\n"
"uint8 rtc_day\n"
"uint8 rtc_hour\n"
"uint8 rtc_minute\n"
"uint8 rtc_second\n"
"uint8 rtc_hundredth\n"
"bool error_demod1       #flags from BIT result\n"
"bool error_demod0\n"
"bool error_timingcard\n"
"uint32 sound_vel        #ec --> m/s\n"
"float64 depth           #ed --> m\n"
"float64 heading         #eh --> degrees\n"
"float64 pitch           #ep --> degrees\n"
"float64 roll            #er --> degrees\n"
"uint16 salinity         #es -->ppm?\n"
"float64 temperature     #et -->deg C or deg F\n"
"\n"
"duration mpt_wait       #Minimum prep-ping waiting time\n"
"float64 heading_std     #standard deviations\n"
"float64 pitch_std\n"
"float64 roll_std\n"
"uint8[8] adc              #analog-digital converter from dsp board\n"
"\n"
"bool error_busexception #error_status_word0\n"
"bool error_address\n"
"bool error_illegalinstruction\n"
"bool error_zerodivide\n"
"bool error_emulator\n"
"bool error_unassigned\n"
"bool error_watchdogrestart\n"
"bool error_batterysaver\n"
"bool error_pinging      #error_status_word1\n"
"bool error_coldwakeup\n"
"bool error_unknwakeup\n"
"bool error_clockread    #error_status_word2\n"
"bool error_unexpectedalarm\n"
"bool error_clockforward\n"
"bool error_clockbackward\n"
"bool error_powerfail    #error_status_word3\n"
"bool error_interrupt4dsp\n"
"bool error_interrupt5uart\n"
"bool error_interrupt6clock\n"
"bool error_interrupt7\n"
"float64 pressure\n"
"float64 pressure_variance\n"
"\n"
"time y2k_time           #Y2K-compliant real-time clock for current data ensemble\n"
"\n"
"# Only available on pioneer\n"
"bool leak_valid\n"
"uint8 leak_status\n"
"bool leakA_detected\n"
"bool leakA_open\n"
"bool leakB_detected\n"
"bool leakB_open\n"
"uint16 leakA_raw # Raw A2D counts\n"
"uint16 leakB_raw # Raw A2D counts\n"
"float32 tx_voltage # Volts\n"
"float32 tx_current # Amps\n"
"float32 transducer_impedence # Ohms\n"
"\n"
"\n"
"####################\n"
"# DVL bottom track #\n"
"####################\n"
"\n"
"#  All distances are in cm, velocities in mm/s, intensities in dB\n"
"\n"
"uint16 pings_per_ensemble\n"
"uint16 delay\n"
"uint8 corr_mag_min\n"
"uint8 eval_amp_min\n"
"uint8 percent_good_min\n"
"uint8 mode\n"
"uint32 err_vel_max\n"
"float32[4] range\n"
"float32[4] velocity\n"
"float32[4] correlation\n"
"uint8[4] eval_amp\n"
"uint8[4] percent_good\n"
"uint32 ref_min\n"
"float32 ref_near\n"
"float32 ref_far\n"
"int32[4] ref_velocity\n"
"uint32[4] ref_correlation\n"
"float32[4] ref_intensity\n"
"uint8[4] ref_percent_good\n"
"uint16 depth_max\n"
"uint32[4] rssi_amp      #Receiver Signal Strength indicator\n"
"uint8 gain\n"
"\n"
"############################\n"
"# High-resolution velocity #\n"
"############################\n"
"\n"
"bool highres_valid\n"
"float32[4] highres_bt_velocity\n"
"float32[4] highres_bt_dmg\n"
"float32[4] highres_wm_velocity\n"
"float32[4] highres_wm_dmg\n"
"float32 highres_sound_vel\n"
"\n"
"\n"
"######################\n"
"# Bottom Track Range #\n"
"######################\n"
"\n"
"bool btrange_valid\n"
"float32 btrange_slant_range\n"
"float32 btrange_axis_delta_range\n"
"float32 btrange_vertical_range\n"
"uint8 btrange_pct_good_4beam\n"
"uint8 btrange_pct_good_beam12\n"
"uint8 btrange_pct_good_beam34\n"
"float32[4] btrange_raw_range\n"
"uint8[4] btrange_max_filter\n"
"uint8[4] btrange_max_amp\n"
"\n"
"#########################\n"
"# Navigation Parameters #\n"
"#########################\n"
"\n"
"uint8 NAVP_BT_MODE_DEEP=0\n"
"uint8 NAVP_BT_MODE_SHALLOW=1\n"
"\n"
"bool navp_valid\n"
"float32[4] navp_time_to_bottom         # seconds from trigger\n"
"float32[4] navp_bottomtrack_stddev     # m/s\n"
"float32[4] navp_bottomtrack_valid_time # seconds from trigger\n"
"uint8 navp_bottomtrack_shallow_mode\n"
"float32[4] navp_time_to_watermass      # seconds from trigger\n"
"float32[4] navp_watertrack_stddev      # m/s\n"
"float32[4] navp_watertrack_valid_time  # seconds from trigger\n"
"float32 navp_watertrack_range\n"
"\n"
"\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
"\n"
"================================================================================\n"
"MSG: ds_core_msgs/DsHeader\n"
"# This is half our standard header for ds_msgs; see\n"
"# HEADERS.md for details\n"
"\n"
"# This header should ALWAYS be paired with a std_msgs/Header\n"
"# and should ALWAYS reference HEADERS.md.  If you're looking at this\n"
"# file to add headers to a type, you probably want to copy/paste\n"
"# the following block:\n"
"#\n"
"#     # The standard 2-part DsHeader block\n"
"#     # This allows both a standard ROS header and DS-specific header blocks\n"
"#     # See HEADERS.md in ds_core_msgs for details\n"
"#     std_msgs/Header header\n"
"#     ds_core_msgs/DsHeader ds_header\n"
"#\n"
"\n"
"# Time data was received or sent out (i/o time)\n"
"time io_time\n"
"\n"
"# Sensor source UUID\n"
"uint8[16] source_uuid\n"
"\n"
;
  }

  static const char* value(const ::ds_sensor_msgs::RdiPD0_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::ds_sensor_msgs::RdiPD0_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.ds_header);
      stream.next(m.dvl_type);
      stream.next(m.altitude_sum);
      stream.next(m.speed_gnd);
      stream.next(m.course_gnd);
      stream.next(m.good_beams);
      stream.next(m.dvl_time);
      stream.next(m.fw_ver);
      stream.next(m.fw_rev);
      stream.next(m.config_khz);
      stream.next(m.carrier_frequency_hz);
      stream.next(m.config_convex);
      stream.next(m.config_sensornum);
      stream.next(m.config_xdcr);
      stream.next(m.config_up);
      stream.next(m.config_beamangle);
      stream.next(m.config_janus);
      stream.next(m.real_sim);
      stream.next(m.lag);
      stream.next(m.beams);
      stream.next(m.cells);
      stream.next(m.pings);
      stream.next(m.cell_depth);
      stream.next(m.blank);
      stream.next(m.signal_proc);
      stream.next(m.min_thresh);
      stream.next(m.code_reps);
      stream.next(m.min_good_pings);
      stream.next(m.good_thresh);
      stream.next(m.ping_interval);
      stream.next(m.coord_mode);
      stream.next(m.coord_tilts);
      stream.next(m.coord_3beam);
      stream.next(m.coord_binmapping);
      stream.next(m.hdng_align);
      stream.next(m.hdng_bias);
      stream.next(m.sensor_src);
      stream.next(m.sensor_avail);
      stream.next(m.bin1_dist);
      stream.next(m.xmit_pulse_len);
      stream.next(m.avg_start);
      stream.next(m.avg_end);
      stream.next(m.avg_false_thresh);
      stream.next(m.trans_lag_dist);
      stream.next(m.serial_num_cpu);
      stream.next(m.wb_cmd);
      stream.next(m.power);
      stream.next(m.serial_num);
      stream.next(m.beam_angle);
      stream.next(m.ensemble_num);
      stream.next(m.BIT);
      stream.next(m.rtc_time);
      stream.next(m.rtc_year);
      stream.next(m.rtc_month);
      stream.next(m.rtc_day);
      stream.next(m.rtc_hour);
      stream.next(m.rtc_minute);
      stream.next(m.rtc_second);
      stream.next(m.rtc_hundredth);
      stream.next(m.error_demod1);
      stream.next(m.error_demod0);
      stream.next(m.error_timingcard);
      stream.next(m.sound_vel);
      stream.next(m.depth);
      stream.next(m.heading);
      stream.next(m.pitch);
      stream.next(m.roll);
      stream.next(m.salinity);
      stream.next(m.temperature);
      stream.next(m.mpt_wait);
      stream.next(m.heading_std);
      stream.next(m.pitch_std);
      stream.next(m.roll_std);
      stream.next(m.adc);
      stream.next(m.error_busexception);
      stream.next(m.error_address);
      stream.next(m.error_illegalinstruction);
      stream.next(m.error_zerodivide);
      stream.next(m.error_emulator);
      stream.next(m.error_unassigned);
      stream.next(m.error_watchdogrestart);
      stream.next(m.error_batterysaver);
      stream.next(m.error_pinging);
      stream.next(m.error_coldwakeup);
      stream.next(m.error_unknwakeup);
      stream.next(m.error_clockread);
      stream.next(m.error_unexpectedalarm);
      stream.next(m.error_clockforward);
      stream.next(m.error_clockbackward);
      stream.next(m.error_powerfail);
      stream.next(m.error_interrupt4dsp);
      stream.next(m.error_interrupt5uart);
      stream.next(m.error_interrupt6clock);
      stream.next(m.error_interrupt7);
      stream.next(m.pressure);
      stream.next(m.pressure_variance);
      stream.next(m.y2k_time);
      stream.next(m.leak_valid);
      stream.next(m.leak_status);
      stream.next(m.leakA_detected);
      stream.next(m.leakA_open);
      stream.next(m.leakB_detected);
      stream.next(m.leakB_open);
      stream.next(m.leakA_raw);
      stream.next(m.leakB_raw);
      stream.next(m.tx_voltage);
      stream.next(m.tx_current);
      stream.next(m.transducer_impedence);
      stream.next(m.pings_per_ensemble);
      stream.next(m.delay);
      stream.next(m.corr_mag_min);
      stream.next(m.eval_amp_min);
      stream.next(m.percent_good_min);
      stream.next(m.mode);
      stream.next(m.err_vel_max);
      stream.next(m.range);
      stream.next(m.velocity);
      stream.next(m.correlation);
      stream.next(m.eval_amp);
      stream.next(m.percent_good);
      stream.next(m.ref_min);
      stream.next(m.ref_near);
      stream.next(m.ref_far);
      stream.next(m.ref_velocity);
      stream.next(m.ref_correlation);
      stream.next(m.ref_intensity);
      stream.next(m.ref_percent_good);
      stream.next(m.depth_max);
      stream.next(m.rssi_amp);
      stream.next(m.gain);
      stream.next(m.highres_valid);
      stream.next(m.highres_bt_velocity);
      stream.next(m.highres_bt_dmg);
      stream.next(m.highres_wm_velocity);
      stream.next(m.highres_wm_dmg);
      stream.next(m.highres_sound_vel);
      stream.next(m.btrange_valid);
      stream.next(m.btrange_slant_range);
      stream.next(m.btrange_axis_delta_range);
      stream.next(m.btrange_vertical_range);
      stream.next(m.btrange_pct_good_4beam);
      stream.next(m.btrange_pct_good_beam12);
      stream.next(m.btrange_pct_good_beam34);
      stream.next(m.btrange_raw_range);
      stream.next(m.btrange_max_filter);
      stream.next(m.btrange_max_amp);
      stream.next(m.navp_valid);
      stream.next(m.navp_time_to_bottom);
      stream.next(m.navp_bottomtrack_stddev);
      stream.next(m.navp_bottomtrack_valid_time);
      stream.next(m.navp_bottomtrack_shallow_mode);
      stream.next(m.navp_time_to_watermass);
      stream.next(m.navp_watertrack_stddev);
      stream.next(m.navp_watertrack_valid_time);
      stream.next(m.navp_watertrack_range);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct RdiPD0_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::ds_sensor_msgs::RdiPD0_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::ds_sensor_msgs::RdiPD0_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "ds_header: ";
    s << std::endl;
    Printer< ::ds_core_msgs::DsHeader_<ContainerAllocator> >::stream(s, indent + "  ", v.ds_header);
    s << indent << "dvl_type: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.dvl_type);
    s << indent << "altitude_sum: ";
    Printer<double>::stream(s, indent + "  ", v.altitude_sum);
    s << indent << "speed_gnd: ";
    Printer<double>::stream(s, indent + "  ", v.speed_gnd);
    s << indent << "course_gnd: ";
    Printer<double>::stream(s, indent + "  ", v.course_gnd);
    s << indent << "good_beams: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.good_beams);
    s << indent << "dvl_time: ";
    Printer<double>::stream(s, indent + "  ", v.dvl_time);
    s << indent << "fw_ver: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.fw_ver);
    s << indent << "fw_rev: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.fw_rev);
    s << indent << "config_khz: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.config_khz);
    s << indent << "carrier_frequency_hz: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.carrier_frequency_hz);
    s << indent << "config_convex: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.config_convex);
    s << indent << "config_sensornum: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.config_sensornum);
    s << indent << "config_xdcr: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.config_xdcr);
    s << indent << "config_up: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.config_up);
    s << indent << "config_beamangle: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.config_beamangle);
    s << indent << "config_janus: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.config_janus);
    s << indent << "real_sim: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.real_sim);
    s << indent << "lag: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.lag);
    s << indent << "beams: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.beams);
    s << indent << "cells: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.cells);
    s << indent << "pings: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.pings);
    s << indent << "cell_depth: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.cell_depth);
    s << indent << "blank: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.blank);
    s << indent << "signal_proc: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.signal_proc);
    s << indent << "min_thresh: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.min_thresh);
    s << indent << "code_reps: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.code_reps);
    s << indent << "min_good_pings: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.min_good_pings);
    s << indent << "good_thresh: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.good_thresh);
    s << indent << "ping_interval: ";
    Printer<ros::Duration>::stream(s, indent + "  ", v.ping_interval);
    s << indent << "coord_mode: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.coord_mode);
    s << indent << "coord_tilts: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.coord_tilts);
    s << indent << "coord_3beam: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.coord_3beam);
    s << indent << "coord_binmapping: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.coord_binmapping);
    s << indent << "hdng_align: ";
    Printer<double>::stream(s, indent + "  ", v.hdng_align);
    s << indent << "hdng_bias: ";
    Printer<double>::stream(s, indent + "  ", v.hdng_bias);
    s << indent << "sensor_src: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.sensor_src);
    s << indent << "sensor_avail: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.sensor_avail);
    s << indent << "bin1_dist: ";
    Printer<float>::stream(s, indent + "  ", v.bin1_dist);
    s << indent << "xmit_pulse_len: ";
    Printer<float>::stream(s, indent + "  ", v.xmit_pulse_len);
    s << indent << "avg_start: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.avg_start);
    s << indent << "avg_end: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.avg_end);
    s << indent << "avg_false_thresh: ";
    Printer<float>::stream(s, indent + "  ", v.avg_false_thresh);
    s << indent << "trans_lag_dist: ";
    Printer<float>::stream(s, indent + "  ", v.trans_lag_dist);
    s << indent << "serial_num_cpu[]" << std::endl;
    for (size_t i = 0; i < v.serial_num_cpu.size(); ++i)
    {
      s << indent << "  serial_num_cpu[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.serial_num_cpu[i]);
    }
    s << indent << "wb_cmd: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.wb_cmd);
    s << indent << "power: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.power);
    s << indent << "serial_num: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.serial_num);
    s << indent << "beam_angle: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.beam_angle);
    s << indent << "ensemble_num: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.ensemble_num);
    s << indent << "BIT: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.BIT);
    s << indent << "rtc_time: ";
    Printer<ros::Time>::stream(s, indent + "  ", v.rtc_time);
    s << indent << "rtc_year: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.rtc_year);
    s << indent << "rtc_month: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.rtc_month);
    s << indent << "rtc_day: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.rtc_day);
    s << indent << "rtc_hour: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.rtc_hour);
    s << indent << "rtc_minute: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.rtc_minute);
    s << indent << "rtc_second: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.rtc_second);
    s << indent << "rtc_hundredth: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.rtc_hundredth);
    s << indent << "error_demod1: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.error_demod1);
    s << indent << "error_demod0: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.error_demod0);
    s << indent << "error_timingcard: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.error_timingcard);
    s << indent << "sound_vel: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.sound_vel);
    s << indent << "depth: ";
    Printer<double>::stream(s, indent + "  ", v.depth);
    s << indent << "heading: ";
    Printer<double>::stream(s, indent + "  ", v.heading);
    s << indent << "pitch: ";
    Printer<double>::stream(s, indent + "  ", v.pitch);
    s << indent << "roll: ";
    Printer<double>::stream(s, indent + "  ", v.roll);
    s << indent << "salinity: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.salinity);
    s << indent << "temperature: ";
    Printer<double>::stream(s, indent + "  ", v.temperature);
    s << indent << "mpt_wait: ";
    Printer<ros::Duration>::stream(s, indent + "  ", v.mpt_wait);
    s << indent << "heading_std: ";
    Printer<double>::stream(s, indent + "  ", v.heading_std);
    s << indent << "pitch_std: ";
    Printer<double>::stream(s, indent + "  ", v.pitch_std);
    s << indent << "roll_std: ";
    Printer<double>::stream(s, indent + "  ", v.roll_std);
    s << indent << "adc[]" << std::endl;
    for (size_t i = 0; i < v.adc.size(); ++i)
    {
      s << indent << "  adc[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.adc[i]);
    }
    s << indent << "error_busexception: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.error_busexception);
    s << indent << "error_address: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.error_address);
    s << indent << "error_illegalinstruction: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.error_illegalinstruction);
    s << indent << "error_zerodivide: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.error_zerodivide);
    s << indent << "error_emulator: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.error_emulator);
    s << indent << "error_unassigned: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.error_unassigned);
    s << indent << "error_watchdogrestart: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.error_watchdogrestart);
    s << indent << "error_batterysaver: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.error_batterysaver);
    s << indent << "error_pinging: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.error_pinging);
    s << indent << "error_coldwakeup: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.error_coldwakeup);
    s << indent << "error_unknwakeup: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.error_unknwakeup);
    s << indent << "error_clockread: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.error_clockread);
    s << indent << "error_unexpectedalarm: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.error_unexpectedalarm);
    s << indent << "error_clockforward: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.error_clockforward);
    s << indent << "error_clockbackward: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.error_clockbackward);
    s << indent << "error_powerfail: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.error_powerfail);
    s << indent << "error_interrupt4dsp: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.error_interrupt4dsp);
    s << indent << "error_interrupt5uart: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.error_interrupt5uart);
    s << indent << "error_interrupt6clock: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.error_interrupt6clock);
    s << indent << "error_interrupt7: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.error_interrupt7);
    s << indent << "pressure: ";
    Printer<double>::stream(s, indent + "  ", v.pressure);
    s << indent << "pressure_variance: ";
    Printer<double>::stream(s, indent + "  ", v.pressure_variance);
    s << indent << "y2k_time: ";
    Printer<ros::Time>::stream(s, indent + "  ", v.y2k_time);
    s << indent << "leak_valid: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.leak_valid);
    s << indent << "leak_status: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.leak_status);
    s << indent << "leakA_detected: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.leakA_detected);
    s << indent << "leakA_open: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.leakA_open);
    s << indent << "leakB_detected: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.leakB_detected);
    s << indent << "leakB_open: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.leakB_open);
    s << indent << "leakA_raw: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.leakA_raw);
    s << indent << "leakB_raw: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.leakB_raw);
    s << indent << "tx_voltage: ";
    Printer<float>::stream(s, indent + "  ", v.tx_voltage);
    s << indent << "tx_current: ";
    Printer<float>::stream(s, indent + "  ", v.tx_current);
    s << indent << "transducer_impedence: ";
    Printer<float>::stream(s, indent + "  ", v.transducer_impedence);
    s << indent << "pings_per_ensemble: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.pings_per_ensemble);
    s << indent << "delay: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.delay);
    s << indent << "corr_mag_min: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.corr_mag_min);
    s << indent << "eval_amp_min: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.eval_amp_min);
    s << indent << "percent_good_min: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.percent_good_min);
    s << indent << "mode: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.mode);
    s << indent << "err_vel_max: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.err_vel_max);
    s << indent << "range[]" << std::endl;
    for (size_t i = 0; i < v.range.size(); ++i)
    {
      s << indent << "  range[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.range[i]);
    }
    s << indent << "velocity[]" << std::endl;
    for (size_t i = 0; i < v.velocity.size(); ++i)
    {
      s << indent << "  velocity[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.velocity[i]);
    }
    s << indent << "correlation[]" << std::endl;
    for (size_t i = 0; i < v.correlation.size(); ++i)
    {
      s << indent << "  correlation[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.correlation[i]);
    }
    s << indent << "eval_amp[]" << std::endl;
    for (size_t i = 0; i < v.eval_amp.size(); ++i)
    {
      s << indent << "  eval_amp[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.eval_amp[i]);
    }
    s << indent << "percent_good[]" << std::endl;
    for (size_t i = 0; i < v.percent_good.size(); ++i)
    {
      s << indent << "  percent_good[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.percent_good[i]);
    }
    s << indent << "ref_min: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.ref_min);
    s << indent << "ref_near: ";
    Printer<float>::stream(s, indent + "  ", v.ref_near);
    s << indent << "ref_far: ";
    Printer<float>::stream(s, indent + "  ", v.ref_far);
    s << indent << "ref_velocity[]" << std::endl;
    for (size_t i = 0; i < v.ref_velocity.size(); ++i)
    {
      s << indent << "  ref_velocity[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.ref_velocity[i]);
    }
    s << indent << "ref_correlation[]" << std::endl;
    for (size_t i = 0; i < v.ref_correlation.size(); ++i)
    {
      s << indent << "  ref_correlation[" << i << "]: ";
      Printer<uint32_t>::stream(s, indent + "  ", v.ref_correlation[i]);
    }
    s << indent << "ref_intensity[]" << std::endl;
    for (size_t i = 0; i < v.ref_intensity.size(); ++i)
    {
      s << indent << "  ref_intensity[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.ref_intensity[i]);
    }
    s << indent << "ref_percent_good[]" << std::endl;
    for (size_t i = 0; i < v.ref_percent_good.size(); ++i)
    {
      s << indent << "  ref_percent_good[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.ref_percent_good[i]);
    }
    s << indent << "depth_max: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.depth_max);
    s << indent << "rssi_amp[]" << std::endl;
    for (size_t i = 0; i < v.rssi_amp.size(); ++i)
    {
      s << indent << "  rssi_amp[" << i << "]: ";
      Printer<uint32_t>::stream(s, indent + "  ", v.rssi_amp[i]);
    }
    s << indent << "gain: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.gain);
    s << indent << "highres_valid: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.highres_valid);
    s << indent << "highres_bt_velocity[]" << std::endl;
    for (size_t i = 0; i < v.highres_bt_velocity.size(); ++i)
    {
      s << indent << "  highres_bt_velocity[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.highres_bt_velocity[i]);
    }
    s << indent << "highres_bt_dmg[]" << std::endl;
    for (size_t i = 0; i < v.highres_bt_dmg.size(); ++i)
    {
      s << indent << "  highres_bt_dmg[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.highres_bt_dmg[i]);
    }
    s << indent << "highres_wm_velocity[]" << std::endl;
    for (size_t i = 0; i < v.highres_wm_velocity.size(); ++i)
    {
      s << indent << "  highres_wm_velocity[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.highres_wm_velocity[i]);
    }
    s << indent << "highres_wm_dmg[]" << std::endl;
    for (size_t i = 0; i < v.highres_wm_dmg.size(); ++i)
    {
      s << indent << "  highres_wm_dmg[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.highres_wm_dmg[i]);
    }
    s << indent << "highres_sound_vel: ";
    Printer<float>::stream(s, indent + "  ", v.highres_sound_vel);
    s << indent << "btrange_valid: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.btrange_valid);
    s << indent << "btrange_slant_range: ";
    Printer<float>::stream(s, indent + "  ", v.btrange_slant_range);
    s << indent << "btrange_axis_delta_range: ";
    Printer<float>::stream(s, indent + "  ", v.btrange_axis_delta_range);
    s << indent << "btrange_vertical_range: ";
    Printer<float>::stream(s, indent + "  ", v.btrange_vertical_range);
    s << indent << "btrange_pct_good_4beam: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.btrange_pct_good_4beam);
    s << indent << "btrange_pct_good_beam12: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.btrange_pct_good_beam12);
    s << indent << "btrange_pct_good_beam34: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.btrange_pct_good_beam34);
    s << indent << "btrange_raw_range[]" << std::endl;
    for (size_t i = 0; i < v.btrange_raw_range.size(); ++i)
    {
      s << indent << "  btrange_raw_range[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.btrange_raw_range[i]);
    }
    s << indent << "btrange_max_filter[]" << std::endl;
    for (size_t i = 0; i < v.btrange_max_filter.size(); ++i)
    {
      s << indent << "  btrange_max_filter[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.btrange_max_filter[i]);
    }
    s << indent << "btrange_max_amp[]" << std::endl;
    for (size_t i = 0; i < v.btrange_max_amp.size(); ++i)
    {
      s << indent << "  btrange_max_amp[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.btrange_max_amp[i]);
    }
    s << indent << "navp_valid: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.navp_valid);
    s << indent << "navp_time_to_bottom[]" << std::endl;
    for (size_t i = 0; i < v.navp_time_to_bottom.size(); ++i)
    {
      s << indent << "  navp_time_to_bottom[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.navp_time_to_bottom[i]);
    }
    s << indent << "navp_bottomtrack_stddev[]" << std::endl;
    for (size_t i = 0; i < v.navp_bottomtrack_stddev.size(); ++i)
    {
      s << indent << "  navp_bottomtrack_stddev[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.navp_bottomtrack_stddev[i]);
    }
    s << indent << "navp_bottomtrack_valid_time[]" << std::endl;
    for (size_t i = 0; i < v.navp_bottomtrack_valid_time.size(); ++i)
    {
      s << indent << "  navp_bottomtrack_valid_time[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.navp_bottomtrack_valid_time[i]);
    }
    s << indent << "navp_bottomtrack_shallow_mode: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.navp_bottomtrack_shallow_mode);
    s << indent << "navp_time_to_watermass[]" << std::endl;
    for (size_t i = 0; i < v.navp_time_to_watermass.size(); ++i)
    {
      s << indent << "  navp_time_to_watermass[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.navp_time_to_watermass[i]);
    }
    s << indent << "navp_watertrack_stddev[]" << std::endl;
    for (size_t i = 0; i < v.navp_watertrack_stddev.size(); ++i)
    {
      s << indent << "  navp_watertrack_stddev[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.navp_watertrack_stddev[i]);
    }
    s << indent << "navp_watertrack_valid_time[]" << std::endl;
    for (size_t i = 0; i < v.navp_watertrack_valid_time.size(); ++i)
    {
      s << indent << "  navp_watertrack_valid_time[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.navp_watertrack_valid_time[i]);
    }
    s << indent << "navp_watertrack_range: ";
    Printer<float>::stream(s, indent + "  ", v.navp_watertrack_range);
  }
};

} // namespace message_operations
} // namespace ros

#endif // DS_SENSOR_MSGS_MESSAGE_RDIPD0_H
